PTHREAD_ATTR_INIT(3)                              Linux Programmer's Manual                             PTHREAD_ATTR_INIT(3)



NAME
       pthread_attr_init, pthread_attr_destroy - initialize and destroy thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_init(pthread_attr_t *attr);
       int pthread_attr_destroy(pthread_attr_t *attr);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_attr_init()  function initializes the thread attributes object pointed to by attr with default attribute
       values.  After this call, individual attributes of the object can be set  using  various  related  functions  (listed
       under SEE ALSO), and then the object can be used in one or more pthread_create(3) calls that create threads.

       Calling  pthread_attr_init()  on  a  thread  attributes object that has already been initialized results in undefined
       behavior.

       When a thread attributes object is no longer required, it should be destroyed using the pthread_attr_destroy()  func‐
       tion.  Destroying a thread attributes object has no effect on threads that were created using that object.

       Once a thread attributes object has been destroyed, it can be reinitialized using pthread_attr_init().  Any other use
       of a destroyed thread attributes object has undefined results.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       POSIX.1-2001 documents an ENOMEM error for pthread_attr_init(); on Linux these functions always succeed (but portable
       and future-proof applications should nevertheless handle a possible error return).

CONFORMING TO
       POSIX.1-2001.

NOTES
       The  pthread_attr_t  type  should be treated as opaque: any access to the object other than via pthreads functions is
       nonportable and produces undefined results.

EXAMPLE
       The program below optionally makes use of pthread_attr_init() and various related functions to  initialize  a  thread
       attributes  object  that  is  used to create a single thread.  Once created, the thread uses the pthread_getattr_np()
       function (a nonstandard GNU extension) to retrieve the thread's attributes, and then displays those attributes.

       If the program is run with no command-line argument, then it passes NULL as the attr argument  of  pthread_create(3),
       so  that  the thread is created with default attributes.  Running the program on Linux/x86-32 with the NPTL threading
       implementation, we see the following:

           $ ulimit -s       # No stack imit ==> default stack size is 2MB
           unlimited
           $ ./a.out
           Thread attributes:
                   Detach state        = PTHREAD_CREATE_JOINABLE
                   Scope               = PTHREAD_SCOPE_SYSTEM
                   Inherit scheduler   = PTHREAD_INHERIT_SCHED
                   Scheduling policy   = SCHED_OTHER
                   Scheduling priority = 0
                   Guard size          = 4096 bytes
                   Stack address       = 0x40196000
                   Stack size          = 0x201000 bytes

       When we supply a stack size as a command-line argument, the program initializes a thread attributes object, sets var‐
       ious  attributes  in  that  object, and passes a pointer to the object in the call to pthread_create(3).  Running the
       program on Linux/x86-32 with the NPTL threading implementation, we see the following:

           $ ./a.out 0x3000000
           posix_memalign() allocated at 0x40197000
           Thread attributes:
                   Detach state        = PTHREAD_CREATE_DETACHED
                   Scope               = PTHREAD_SCOPE_SYSTEM
                   Inherit scheduler   = PTHREAD_EXPLICIT_SCHED
                   Scheduling policy   = SCHED_OTHER
                   Scheduling priority = 0
                   Guard size          = 0 bytes
                   Stack address       = 0x40197000
                   Stack size          = 0x3000000 bytes

   Program source

       #define _GNU_SOURCE     /* To get pthread_getattr_np() declaration */
       #include <pthread.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <errno.h>

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       static void
       display_pthread_attr(pthread_attr_t *attr, char *prefix)
       {
           int s, i;
           size_t v;
           void *stkaddr;
           struct sched_param sp;

           s = pthread_attr_getdetachstate(attr, &i);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getdetachstate");
           printf("%sDetach state        = %s\n", prefix,
                   (i == PTHREAD_CREATE_DETACHED) ? "PTHREAD_CREATE_DETACHED" :
                   (i == PTHREAD_CREATE_JOINABLE) ? "PTHREAD_CREATE_JOINABLE" :
                   "???");

           s = pthread_attr_getscope(attr, &i);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getscope");
           printf("%sScope               = %s\n", prefix,
                   (i == PTHREAD_SCOPE_SYSTEM)  ? "PTHREAD_SCOPE_SYSTEM" :
                   (i == PTHREAD_SCOPE_PROCESS) ? "PTHREAD_SCOPE_PROCESS" :
                   "???");

           s = pthread_attr_getinheritsched(attr, &i);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getinheritsched");
           printf("%sInherit scheduler   = %s\n", prefix,
                   (i == PTHREAD_INHERIT_SCHED)  ? "PTHREAD_INHERIT_SCHED" :
                   (i == PTHREAD_EXPLICIT_SCHED) ? "PTHREAD_EXPLICIT_SCHED" :
                   "???");

           s = pthread_attr_getschedpolicy(attr, &i);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getschedpolicy");
           printf("%sScheduling policy   = %s\n", prefix,
                   (i == SCHED_OTHER) ? "SCHED_OTHER" :
                   (i == SCHED_FIFO)  ? "SCHED_FIFO" :
                   (i == SCHED_RR)    ? "SCHED_RR" :
                   "???");

           s = pthread_attr_getschedparam(attr, &sp);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getschedparam");
           printf("%sScheduling priority = %d\n", prefix, sp.sched_priority);

           s = pthread_attr_getguardsize(attr, &v);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getguardsize");
           printf("%sGuard size          = %d bytes\n", prefix, v);

           s = pthread_attr_getstack(attr, &stkaddr, &v);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getstack");
           printf("%sStack address       = %p\n", prefix, stkaddr);
           printf("%sStack size          = 0x%x bytes\n", prefix, v);
       }

       static void *
       thread_start(void *arg)
       {
           int s;
           pthread_attr_t gattr;

           /* pthread_getattr_np() is a non-standard GNU extension that
              retrieves the attributes of the thread specified in its
              first argument */

           s = pthread_getattr_np(pthread_self(), &gattr);
           if (s != 0)
               handle_error_en(s, "pthread_getattr_np");

           printf("Thread attributes:\n");
           display_pthread_attr(&gattr, "\t");

           exit(EXIT_SUCCESS);         /* Terminate all threads */
       }

       int
       main(int argc, char *argv[])
       {
           pthread_t thr;
           pthread_attr_t attr;
           pthread_attr_t *attrp;      /* NULL or &attr */
           int s;

           attrp = NULL;

           /* If a command-line argument was supplied, use it to set the
              stack-size attribute and set a few other thread attributes,
              and set attrp pointing to thread attributes object */

           if (argc > 1) {
               int stack_size;
               void *sp;

               attrp = &attr;

               s = pthread_attr_init(&attr);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_init");

               s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setdetachstate");

               s = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setinheritsched");

               stack_size = strtoul(argv[1], NULL, 0);

               s = posix_memalign(&sp, sysconf(_SC_PAGESIZE), stack_size);
               if (s != 0)
                   handle_error_en(s, "posix_memalign");

               printf("posix_memalign() allocated at %p\n", sp);

               s = pthread_attr_setstack(&attr, sp, stack_size);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setstack");
           }

           s = pthread_create(&thr, attrp, &thread_start, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           if (attrp != NULL) {
               s = pthread_attr_destroy(attrp);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_destroy");
           }

           pause();    /* Terminates when other thread calls exit() */
       }

SEE ALSO
       pthread_attr_setaffinity_np(3), pthread_attr_setdetachstate(3), pthread_attr_setguardsize(3),  pthread_attr_setinher‐
       itsched(3),       pthread_attr_setschedparam(3),       pthread_attr_setschedpolicy(3),      pthread_attr_setscope(3),
       pthread_attr_setstack(3),     pthread_attr_setstackaddr(3),     pthread_attr_setstacksize(3),      pthread_create(3),
       pthread_getattr_np(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-11                                     PTHREAD_ATTR_INIT(3)
************************************************************************************************************
PTHREAD_ATTR_SETAFFINITY_NP(3)                    Linux Programmer's Manual                   PTHREAD_ATTR_SETAFFINITY_NP(3)



NAME
       pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - set/get CPU affinity attribute in thread attributes object

SYNOPSIS
       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <pthread.h>

       int pthread_attr_setaffinity_np(pthread_attr_t *attr,
                          size_t cpusetsize, const cpu_set_t *cpuset);
       int pthread_attr_getaffinity_np(pthread_attr_t *attr,
                          size_t cpusetsize, cpu_set_t *cpuset);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_attr_setaffinity_np()  function  sets  the  CPU  affinity mask attribute of the thread attributes object
       referred to by attr to the value specified in cpuset.  This attribute determines the CPU affinity mask  of  a  thread
       created using the thread attributes object attr.

       The  pthread_attr_getaffinity_np()  function  returns the CPU affinity mask attribute of the thread attributes object
       referred to by attr in the buffer pointed to by cpuset.

       The argument cpusetsize is the length (in bytes) of the buffer pointed to by cpuset.  Typically, this argument  would
       be specified as sizeof(cpu_set_t).

       For  more  details on CPU affinity masks, see sched_setaffinity(2).  For a description of a set of macros that can be
       used to manipulate and inspect CPU sets, see CPU_SET(3).

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       EINVAL (pthread_attr_setaffinity_np()) cpuset specified a CPU that was outside the set supported by the kernel.  (The
              kernel configuration option CONFIG_NR_CPUS defines the range of the set supported by the kernel data type used
              to represent CPU sets.)

       EINVAL (pthread_attr_getaffinity_np()) A CPU in the affinity mask of the thread attributes object referred to by attr
              lies outside the range specified by cpusetsize (i.e., cpuset/cpusetsize is too small).

       ENOMEM (pthread_attr_setaffinity_np()) Could not allocate memory.

VERSIONS
       These functions are provided by glibc since version 2.3.4.

CONFORMING TO
       These functions are nonstandard GNU extensions; hence the suffix "_np" (nonportable) in the names.

NOTES
       In  glibc 2.3.3 only, versions of these functions were provided that did not have a cpusetsize argument.  Instead the
       CPU set size given to the underlying system calls was always sizeof(cpu_set_t).

SEE ALSO
       sched_setaffinity(2), pthread_attr_init(3), pthread_setaffinity_np(3), cpuset(7), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-09-10                           PTHREAD_ATTR_SETAFFINITY_NP(3)
************************************************************************************************************
PTHREAD_ATTR_SETDETACHSTATE(3)                    Linux Programmer's Manual                   PTHREAD_ATTR_SETDETACHSTATE(3)



NAME
       pthread_attr_setdetachstate, pthread_attr_getdetachstate - set/get detach state attribute in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
       int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_attr_setdetachstate()  function sets the detach state attribute of the thread attributes object referred
       to by attr to the value specified in detachstate.  The detach state attribute determines  whether  a  thread  created
       using the thread attributes object attr will be created in a joinable or a detached state.

       The following values may be specified in detachstate:

       PTHREAD_CREATE_DETACHED
              Threads that are created using attr will be created in a detached state.

       PTHREAD_CREATE_JOINABLE
              Threads that are created using attr will be created in a joinable state.

       The  default  setting  of  the detach state attribute in a newly initialized thread attributes object is PTHREAD_CRE‐
       ATE_JOINABLE.

       The pthread_attr_getdetachstate() returns the detach state attribute of the thread attributes object attr in the buf‐
       fer pointed to by detachstate.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setdetachstate(3) can fail with the following error:

       EINVAL An invalid value was specified in detachstate.

CONFORMING TO
       POSIX.1-2001.

NOTES
       See pthread_create(3) for more details on detached and joinable threads.

       A  thread  that  is  created in a joinable state should eventually either be joined using pthread_join(3) or detached
       using pthread_detach(3); see pthread_create(3).

       It is an error to specify the thread ID of a thread that was  created  in  a  detached  state  in  a  later  call  to
       pthread_detach(3) or pthread_join(3).

EXAMPLE
       See pthread_attr_init(3).

SEE ALSO
       pthread_attr_init(3), pthread_create(3), pthread_detach(3), pthread_join(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-02-03                           PTHREAD_ATTR_SETDETACHSTATE(3)
************************************************************************************************************
PTHREAD_ATTR_SETGUARDSIZE(3)                      Linux Programmer's Manual                     PTHREAD_ATTR_SETGUARDSIZE(3)



NAME
       pthread_attr_setguardsize, pthread_attr_getguardsize - set/get guard size attribute in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
       int pthread_attr_getguardsize(pthread_attr_t *attr, size_t *guardsize);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_attr_setguardsize() function sets the guard size attribute of the thread attributes object referred to by
       attr to the value specified in guardsize.

       If guardsize is greater than 0, then for each new thread created using attr the system allocates an additional region
       of at least guardsize bytes at the end of the thread's stack to act as the guard area for the stack (but see BUGS).

       If guardsize is 0, then new threads created with attr will not have a guard area.

       The default guard size is the same as the system page size.

       If the stack address attribute has been set in attr (using pthread_attr_setstack(3) or pthread_attr_setstackaddr(3)),
       meaning that the caller is allocating the thread's stack, then the guard size attribute is ignored  (i.e.,  no  guard
       area  is  created  by  the system): it is the application's responsibility to handle stack overflow (perhaps by using
       mprotect(2) to manually define a guard area at the end of the stack that it has allocated).

       The pthread_attr_getguardsize() function returns the guard size attribute of the thread attributes object referred to
       by attr in the buffer pointed to by guardsize.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       POSIX.1-2001 documents an EINVAL error if attr or guardsize is invalid.  On Linux these functions always succeed (but
       portable and future-proof applications should nevertheless handle a possible error return).

VERSIONS
       These functions are provided by glibc since version 2.1.

CONFORMING TO
       POSIX.1-2001.

NOTES
       A guard area consists of virtual memory pages that are protected to prevent read and write access.  If a thread over‐
       flows  its  stack into the guard area, then, on most hard architectures, it receives a SIGSEGV signal, thus notifying
       it of the overflow.  Guard areas start on page boundaries, and the guard size is internally rounded up to the  system
       page  size when creating a thread.  (Nevertheless, pthread_attr_getguardsize() returns the guard size that was set by
       pthread_attr_setguardsize().)

       Setting a guard size of 0 may be useful to save memory in an application that creates many  threads  and  knows  that
       stack overflow can never occur.

       Choosing  a  guard size larger than the default size may be necessary for detecting stack overflows if a thread allo‐
       cates large data structures on the stack.

BUGS
       As at glibc 2.8, the NPTL threading implementation includes the guard area within the stack size  allocation,  rather
       than  allocating  extra space at the end of the stack, as POSIX.1 requires.  (This can result in an EINVAL error from
       pthread_create(3) if the guard size value is too large, leaving no space for the actual stack.)

       The obsolete LinuxThreads implementation did the right thing, allocating extra space at the end of the stack for  the
       guard area.

EXAMPLE
       See pthread_getattr_np(3).

SEE ALSO
       mmap(2),   mprotect(2),  pthread_attr_init(3),  pthread_create(3),  pthread_attr_setstack(3),  pthread_attr_setstack‐
       size(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-10-24                             PTHREAD_ATTR_SETGUARDSIZE(3)
************************************************************************************************************
PTHREAD_ATTR_SETINHERITSCHED(3)                   Linux Programmer's Manual                  PTHREAD_ATTR_SETINHERITSCHED(3)



NAME
       pthread_attr_setinheritsched, pthread_attr_getinheritsched - set/get inherit scheduler attribute in thread attributes
       object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setinheritsched(pthread_attr_t *attr,
                                        int inheritsched);
       int pthread_attr_getinheritsched(pthread_attr_t *attr,
                                        int *inheritsched);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_attr_setinheritsched() function sets the inherit scheduler attribute  of  the  thread  attributes  object
       referred  to  by  attr  to the value specified in inheritsched.  The inherit scheduler attribute determines whether a
       thread created using the thread attributes object attr will inherit its scheduling attributes from the calling thread
       or whether it will take them from attr.

       The following values may be specified in inheritsched:

       PTHREAD_INHERIT_SCHED
              Threads  that  are  created  using attr inherit scheduling attributes from the creating thread; the scheduling
              attributes in attr are ignored.

       PTHREAD_EXPLICIT_SCHED
              Threads that are created using attr take  their  scheduling  attributes  from  the  values  specified  by  the
              attributes object.

       The  default  setting  of  the  inherit  scheduler  attribute  in  a  newly  initialized  thread attributes object is
       PTHREAD_INHERIT_SCHED.

       The pthread_attr_getinheritsched() returns the inherit scheduler attribute of the thread attributes  object  attr  in
       the buffer pointed to by inheritsched.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setinheritsched() can fail with the following error:

       EINVAL Invalid value in inheritsched.

       POSIX.1-2001  also  documents  an  optional  ENOTSUP  error ("attempt was made to set the attribute to an unsupported
       value") for pthread_attr_setinheritsched().

CONFORMING TO
       POSIX.1-2001.

EXAMPLE
       See pthread_setschedparam(3).

BUGS
       As at glibc 2.8, if a thread attributes object is initialized using pthread_attr_init(3), then the scheduling  policy
       of  the  attributes  object  is  set to SCHED_OTHER and the scheduling priority is set to 0.  However, if the inherit
       scheduler attribute is then set to PTHREAD_EXPLICIT_SCHED, then a thread created using the attribute  object  wrongly
       inherits its scheduling attributes from the creating thread.  This bug does not occur if either the scheduling policy
       or scheduling priority attribute is explicitly set in the thread attributes object before calling pthread_create(3).

SEE ALSO
       sched_setscheduler(2),    pthread_attr_init(3),    pthread_attr_setschedparam(3),     pthread_attr_setschedpolicy(3),
       pthread_create(3), pthread_setschedparam(3), pthread_setschedprio(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-10                          PTHREAD_ATTR_SETINHERITSCHED(3)
************************************************************************************************************
PTHREAD_ATTR_SETSCHEDPARAM(3)                     Linux Programmer's Manual                    PTHREAD_ATTR_SETSCHEDPARAM(3)



NAME
       pthread_attr_setschedparam, pthread_attr_getschedparam - set/get scheduling parameter attributes in thread attributes
       object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setschedparam(pthread_attr_t *attr,
                                      const struct sched_param *param);
       int pthread_attr_getschedparam(pthread_attr_t *attr,
                                      struct sched_param *param);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_attr_setschedparam() function sets the scheduling parameter attributes of the  thread  attributes  object
       referred to by attr to the values specified in the buffer pointed to by param.  These attributes determine the sched‐
       uling parameters of a thread created using the thread attributes object attr.

       The pthread_attr_getschedparam() returns the scheduling parameter attributes of the thread attributes object attr  in
       the buffer pointed to by param.

       Scheduling parameters are maintained in the following structure:

           struct sched_param {
               int sched_priority;     /* Scheduling priority */
           };

       As  can be seen, only one scheduling parameter is supported.  For details of the permitted ranges for scheduling pri‐
       orities in each scheduling policy, see sched_setscheduler(2).

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       POSIX.1 documents EINVAL and ENOTSUP errors for pthread_attr_setschedparam().  On Linux these functions  always  suc‐
       ceed (but portable and future-proof applications should nevertheless handle a possible error return).

CONFORMING TO
       POSIX.1-2001.

EXAMPLE
       See pthread_setschedparam(3).

NOTES
       See pthread_attr_setschedpolicy(3) for a list of the thread scheduling policies supported on Linux.

SEE ALSO
       sched_get_priority_min(2),      sched_setscheduler(2),     pthread_attr_init(3),     pthread_attr_setinheritsched(3),
       pthread_attr_setschedpolicy(3), pthread_create(3), pthread_setschedparam(3), pthread_setschedprio(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-02-03                            PTHREAD_ATTR_SETSCHEDPARAM(3)
************************************************************************************************************
PTHREAD_ATTR_SETSCHEDPOLICY(3)                    Linux Programmer's Manual                   PTHREAD_ATTR_SETSCHEDPOLICY(3)



NAME
       pthread_attr_setschedpolicy,  pthread_attr_getschedpolicy  - set/get scheduling policy attribute in thread attributes
       object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);
       int pthread_attr_getschedpolicy(pthread_attr_t *attr, int *policy);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_attr_setschedpolicy() function sets the scheduling policy  attribute  of  the  thread  attributes  object
       referred  to  by  attr to the value specified in policy.  This attribute determines the scheduling policy of a thread
       created using the thread attributes object attr.

       The supported values for  policy  are  SCHED_FIFO,  SCHED_RR,  and  SCHED_OTHER,  with  the  semantics  described  in
       sched_setscheduler(2).

       The pthread_attr_getschedpolicy() returns the scheduling policy attribute of the thread attributes object attr in the
       buffer pointed to by policy.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setschedpolicy() can fail with the following error:

       EINVAL Invalid value in policy.

       POSIX.1-2001 also documents an optional ENOTSUP error ("attempt was made to  set  the  attribute  to  an  unsupported
       value") for pthread_attr_setschedpolicy().

CONFORMING TO
       POSIX.1-2001.

EXAMPLE
       See pthread_setschedparam(3).

SEE ALSO
       sched_setscheduler(2),    pthread_attr_init(3),    pthread_attr_setinheritsched(3),    pthread_attr_setschedparam(3),
       pthread_create(3), pthread_setschedparam(3), pthread_setschedprio(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-02-03                           PTHREAD_ATTR_SETSCHEDPOLICY(3)
************************************************************************************************************
PTHREAD_ATTR_SETSCOPE(3)                          Linux Programmer's Manual                         PTHREAD_ATTR_SETSCOPE(3)



NAME
       pthread_attr_setscope, pthread_attr_getscope - set/get contention scope attribute in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setscope(pthread_attr_t *attr, int scope);
       int pthread_attr_getscope(pthread_attr_t *attr, int *scope);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_attr_setscope() function sets the contention scope attribute of the thread attributes object referred to
       by attr to the value specified in scope.  The contention scope attribute defines the set of threads against  which  a
       thread competes for resources such as the CPU.  POSIX.1-2001 specifies two possible values for scope:

       PTHREAD_SCOPE_SYSTEM
              The  thread  competes for resources with all other threads in all processes on the system that are in the same
              scheduling allocation domain (a group of one or more processors).  PTHREAD_SCOPE_SYSTEM threads are  scheduled
              relative to one another according to their scheduling policy and priority.

       PTHREAD_SCOPE_PROCESS
              The  thread  competes for resources with all other threads in the same process that were also created with the
              PTHREAD_SCOPE_PROCESS contention scope.  PTHREAD_SCOPE_PROCESS threads are scheduled relative to other threads
              in  the  process  according  to  their scheduling policy and priority.  POSIX.1-2001 leaves it unspecified how
              these threads contend with other threads in other process on the system or with  other  threads  in  the  same
              process that were created with the PTHREAD_SCOPE_SYSTEM contention scope.

       POSIX.1-2001 only requires that an implementation support one of these contention scopes, but permits both to be sup‐
       ported.  Linux supports PTHREAD_SCOPE_SYSTEM, but not PTHREAD_SCOPE_PROCESS.

       The pthread_attr_getscope() function returns the contention scope attribute of the thread attributes object  referred
       to by attr in the buffer pointed to by scope.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setscope() can fail with the following errors:

       EINVAL An invalid value was specified in scope.

       ENOTSUP
              scope specified the value PTHREAD_SCOPE_PROCESS, which is not supported on Linux.

CONFORMING TO
       POSIX.1-2001.

NOTES
       The  PTHREAD_SCOPE_SYSTEM  contention scope typically indicates that a userspace thread is bound directly to a single
       kernel-scheduling entity.  This is the case on Linux for the obsolete LinuxThreads implementation and the modern NPTL
       implementation, which are both 1:1 threading implementations.

       POSIX.1-2001 specifies that the default contention scope is implementation-defined.

SEE ALSO
       pthread_attr_init(3), pthread_attr_setaffinity_np(3), pthread_attr_setinheritsched(3), pthread_attr_setschedparam(3),
       pthread_attr_setschedpolicy(3), pthread_create(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-10-24                                 PTHREAD_ATTR_SETSCOPE(3)
************************************************************************************************************
PTHREAD_ATTR_SETSTACK(3)                          Linux Programmer's Manual                         PTHREAD_ATTR_SETSTACK(3)



NAME
       pthread_attr_setstack, pthread_attr_getstack - set/get stack attributes in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setstack(pthread_attr_t *attr,
                                 void *stackaddr, size_t stacksize);
       int pthread_attr_getstack(pthread_attr_t *attr,
                                 void **stackaddr, size_t *stacksize);

       Compile and link with -pthread.

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pthread_attr_getstack(), pthread_attr_setstack():
           _POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600

DESCRIPTION
       The pthread_attr_setstack() function sets the stack address and stack size attributes of the thread attributes object
       referred to by attr to the values specified in stackaddr and stacksize, respectively.  These attributes  specify  the
       location  and  size  of  the stack that should be used by a thread that is created using the thread attributes object
       attr.

       stackaddr should point to the lowest addressable byte of a buffer of stacksize bytes that was allocated by the  call‐
       er.  The pages of the allocated buffer should be both readable and writable.

       The  pthread_attr_getstack()  function  returns  the stack address and stack size attributes of the thread attributes
       object referred to by attr in the buffers pointed to by stackaddr and stacksize, respectively.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setstack() can fail with the following error:

       EINVAL stacksize is less than PTHREAD_STACK_MIN (16384) bytes.  On some systems, this error may also occur if  stack‐
              addr or stackaddr + stacksize is not suitably aligned.

       POSIX.1-2001  also documents an EACCES error if the stack area described by stackaddr and stacksize is not both read‐
       able and writable by the caller.

VERSIONS
       These functions are provided by glibc since version 2.2.

CONFORMING TO
       POSIX.1-2001.

NOTES
       These functions are provided for applications that must ensure that a thread's stack is placed in a particular  loca‐
       tion.   For  most  applications,  this  is  not  necessary,  and  the use of these functions should be avoided.  (Use
       pthread_attr_setstacksize(3) if an application simply requires a stack size other than the default.)

       When an application employs pthread_attr_setstack(), it takes over the responsibility of allocating the  stack.   Any
       guard size value that was set using pthread_attr_setguardsize(3) is ignored.  If deemed necessary, it is the applica‐
       tion's responsibility to allocate a guard area (one or more pages protected against reading and  writing)  to  handle
       the possibility of stack overflow.

       The  address  specified  in  stackaddr  should be suitably aligned: for full portability, align it on a page boundary
       (sysconf(_SC_PAGESIZE)).  posix_memalign(3) may be useful for allocation.  Probably, stacksize should also be a  mul‐
       tiple of the system page size.

       If  attr is used to create multiple threads, then the caller must change the stack address attribute between calls to
       pthread_create(3); otherwise, the threads will attempt to use the same memory area for their stacks, and  chaos  will
       ensue.

EXAMPLE
       See pthread_attr_init(3).

SEE ALSO
       mmap(2),  mprotect(2),  posix_memalign(3), pthread_attr_init(3), pthread_attr_setguardsize(3), pthread_attr_setstack‐
       addr(3), pthread_attr_setstacksize(3), pthread_create(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-10-24                                 PTHREAD_ATTR_SETSTACK(3)
************************************************************************************************************
PTHREAD_ATTR_SETSTACKADDR(3)                      Linux Programmer's Manual                     PTHREAD_ATTR_SETSTACKADDR(3)



NAME
       pthread_attr_setstackaddr, pthread_attr_getstackaddr - set/get stack address attribute in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr);
       int pthread_attr_getstackaddr(pthread_attr_t *attr, void **stackaddr);

       Compile and link with -pthread.

DESCRIPTION
       These functions are obsolete: do not use them.  Use pthread_attr_setstack(3) and pthread_attr_getstack(3) instead.

       The pthread_attr_setstackaddr() function sets the stack address attribute of the thread attributes object referred to
       by attr to the value specified in stackaddr.  This attribute specifies the location of the stack that should be  used
       by a thread that is created using the thread attributes object attr.

       stackaddr  should  point to a buffer of at least PTHREAD_STACK_MIN bytes that was allocated by the caller.  The pages
       of the allocated buffer should be both readable and writable.

       The pthread_attr_getstackaddr() function returns the stack address attribute of the thread attributes object referred
       to by attr in the buffer pointed to by stackaddr.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       No errors are defined (but applications should nevertheless handle a possible error return).

VERSIONS
       These functions are provided by glibc since version 2.1.

CONFORMING TO
       POSIX.1-2001  specifies  these functions but marks them as obsolete.  POSIX.1-2008 removes the specification of these
       functions.

NOTES
       Do not use these functions!  They cannot be portably used, since they provide no way of specifying the  direction  of
       growth  or the range of the stack.  For example, on architectures with a stack that grows downwards, stackaddr speci‐
       fies the next address past the highest address of the allocated stack area.  However, on architectures with  a  stack
       that  grows  upwards, stackaddr specifies the lowest address in the allocated stack area.  By contrast, the stackaddr
       used by pthread_attr_setstack(3) and pthread_attr_getstack(3), is always a pointer to the lowest address in the allo‐
       cated stack area (and the stacksize argument specifies the range of the stack).

SEE ALSO
       pthread_attr_init(3), pthread_attr_setstack(3), pthread_attr_setstacksize(3), pthread_create(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-10-24                             PTHREAD_ATTR_SETSTACKADDR(3)
************************************************************************************************************
PTHREAD_ATTR_SETSTACKSIZE(3)                      Linux Programmer's Manual                     PTHREAD_ATTR_SETSTACKSIZE(3)



NAME
       pthread_attr_setstacksize, pthread_attr_getstacksize - set/get stack size attribute in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
       int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_attr_setstacksize() function sets the stack size attribute of the thread attributes object referred to by
       attr to the value specified in stacksize.

       The stack size attribute determines the minimum size (in bytes) that will be allocated for threads created using  the
       thread attributes object attr.

       The pthread_attr_getstacksize() function returns the stack size attribute of the thread attributes object referred to
       by attr in the buffer pointed to by stacksize.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setstacksize() can fail with the following error:

       EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes.

       On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not  a  multiple  of  the
       system page size.

VERSIONS
       These functions are provided by glibc since version 2.1.

CONFORMING TO
       POSIX.1-2001.

EXAMPLE
       See pthread_create(3).

NOTES
       For details on the default stack size of new threads, see pthread_create(3).

       A thread's stack size is fixed at the time of thread creation.  Only the main thread can dynamically grow its stack.

       The  pthread_attr_setstack(3)  function allows an application to set both the size and location of a caller-allocated
       stack that is to be used by a thread.

BUGS
       As at glibc 2.8, if the specified stacksize is not a multiple of STACK_ALIGN (16 bytes on most architectures), it may
       be  rounded  downwards,  in violation of POSIX.1-2001, which says that the allocated stack will be at least stacksize
       bytes.

SEE ALSO
       getrlimit(2),  pthread_attr_init(3),   pthread_attr_setguardsize(3),   pthread_attr_setstack(3),   pthread_create(3),
       pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-05                             PTHREAD_ATTR_SETSTACKSIZE(3)
************************************************************************************************************
PTHREAD_ATTR_INIT(3)                              Linux Programmer's Manual                             PTHREAD_ATTR_INIT(3)



NAME
       pthread_attr_init, pthread_attr_destroy - initialize and destroy thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_init(pthread_attr_t *attr);
       int pthread_attr_destroy(pthread_attr_t *attr);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_attr_init()  function initializes the thread attributes object pointed to by attr with default attribute
       values.  After this call, individual attributes of the object can be set  using  various  related  functions  (listed
       under SEE ALSO), and then the object can be used in one or more pthread_create(3) calls that create threads.

       Calling  pthread_attr_init()  on  a  thread  attributes object that has already been initialized results in undefined
       behavior.

       When a thread attributes object is no longer required, it should be destroyed using the pthread_attr_destroy()  func‐
       tion.  Destroying a thread attributes object has no effect on threads that were created using that object.

       Once a thread attributes object has been destroyed, it can be reinitialized using pthread_attr_init().  Any other use
       of a destroyed thread attributes object has undefined results.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       POSIX.1-2001 documents an ENOMEM error for pthread_attr_init(); on Linux these functions always succeed (but portable
       and future-proof applications should nevertheless handle a possible error return).

CONFORMING TO
       POSIX.1-2001.

NOTES
       The  pthread_attr_t  type  should be treated as opaque: any access to the object other than via pthreads functions is
       nonportable and produces undefined results.

EXAMPLE
       The program below optionally makes use of pthread_attr_init() and various related functions to  initialize  a  thread
       attributes  object  that  is  used to create a single thread.  Once created, the thread uses the pthread_getattr_np()
       function (a nonstandard GNU extension) to retrieve the thread's attributes, and then displays those attributes.

       If the program is run with no command-line argument, then it passes NULL as the attr argument  of  pthread_create(3),
       so  that  the thread is created with default attributes.  Running the program on Linux/x86-32 with the NPTL threading
       implementation, we see the following:

           $ ulimit -s       # No stack imit ==> default stack size is 2MB
           unlimited
           $ ./a.out
           Thread attributes:
                   Detach state        = PTHREAD_CREATE_JOINABLE
                   Scope               = PTHREAD_SCOPE_SYSTEM
                   Inherit scheduler   = PTHREAD_INHERIT_SCHED
                   Scheduling policy   = SCHED_OTHER
                   Scheduling priority = 0
                   Guard size          = 4096 bytes
                   Stack address       = 0x40196000
                   Stack size          = 0x201000 bytes

       When we supply a stack size as a command-line argument, the program initializes a thread attributes object, sets var‐
       ious  attributes  in  that  object, and passes a pointer to the object in the call to pthread_create(3).  Running the
       program on Linux/x86-32 with the NPTL threading implementation, we see the following:

           $ ./a.out 0x3000000
           posix_memalign() allocated at 0x40197000
           Thread attributes:
                   Detach state        = PTHREAD_CREATE_DETACHED
                   Scope               = PTHREAD_SCOPE_SYSTEM
                   Inherit scheduler   = PTHREAD_EXPLICIT_SCHED
                   Scheduling policy   = SCHED_OTHER
                   Scheduling priority = 0
                   Guard size          = 0 bytes
                   Stack address       = 0x40197000
                   Stack size          = 0x3000000 bytes

   Program source

       #define _GNU_SOURCE     /* To get pthread_getattr_np() declaration */
       #include <pthread.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <errno.h>

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       static void
       display_pthread_attr(pthread_attr_t *attr, char *prefix)
       {
           int s, i;
           size_t v;
           void *stkaddr;
           struct sched_param sp;

           s = pthread_attr_getdetachstate(attr, &i);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getdetachstate");
           printf("%sDetach state        = %s\n", prefix,
                   (i == PTHREAD_CREATE_DETACHED) ? "PTHREAD_CREATE_DETACHED" :
                   (i == PTHREAD_CREATE_JOINABLE) ? "PTHREAD_CREATE_JOINABLE" :
                   "???");

           s = pthread_attr_getscope(attr, &i);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getscope");
           printf("%sScope               = %s\n", prefix,
                   (i == PTHREAD_SCOPE_SYSTEM)  ? "PTHREAD_SCOPE_SYSTEM" :
                   (i == PTHREAD_SCOPE_PROCESS) ? "PTHREAD_SCOPE_PROCESS" :
                   "???");

           s = pthread_attr_getinheritsched(attr, &i);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getinheritsched");
           printf("%sInherit scheduler   = %s\n", prefix,
                   (i == PTHREAD_INHERIT_SCHED)  ? "PTHREAD_INHERIT_SCHED" :
                   (i == PTHREAD_EXPLICIT_SCHED) ? "PTHREAD_EXPLICIT_SCHED" :
                   "???");

           s = pthread_attr_getschedpolicy(attr, &i);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getschedpolicy");
           printf("%sScheduling policy   = %s\n", prefix,
                   (i == SCHED_OTHER) ? "SCHED_OTHER" :
                   (i == SCHED_FIFO)  ? "SCHED_FIFO" :
                   (i == SCHED_RR)    ? "SCHED_RR" :
                   "???");

           s = pthread_attr_getschedparam(attr, &sp);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getschedparam");
           printf("%sScheduling priority = %d\n", prefix, sp.sched_priority);

           s = pthread_attr_getguardsize(attr, &v);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getguardsize");
           printf("%sGuard size          = %d bytes\n", prefix, v);

           s = pthread_attr_getstack(attr, &stkaddr, &v);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getstack");
           printf("%sStack address       = %p\n", prefix, stkaddr);
           printf("%sStack size          = 0x%x bytes\n", prefix, v);
       }

       static void *
       thread_start(void *arg)
       {
           int s;
           pthread_attr_t gattr;

           /* pthread_getattr_np() is a non-standard GNU extension that
              retrieves the attributes of the thread specified in its
              first argument */

           s = pthread_getattr_np(pthread_self(), &gattr);
           if (s != 0)
               handle_error_en(s, "pthread_getattr_np");

           printf("Thread attributes:\n");
           display_pthread_attr(&gattr, "\t");

           exit(EXIT_SUCCESS);         /* Terminate all threads */
       }

       int
       main(int argc, char *argv[])
       {
           pthread_t thr;
           pthread_attr_t attr;
           pthread_attr_t *attrp;      /* NULL or &attr */
           int s;

           attrp = NULL;

           /* If a command-line argument was supplied, use it to set the
              stack-size attribute and set a few other thread attributes,
              and set attrp pointing to thread attributes object */

           if (argc > 1) {
               int stack_size;
               void *sp;

               attrp = &attr;

               s = pthread_attr_init(&attr);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_init");

               s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setdetachstate");

               s = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setinheritsched");

               stack_size = strtoul(argv[1], NULL, 0);

               s = posix_memalign(&sp, sysconf(_SC_PAGESIZE), stack_size);
               if (s != 0)
                   handle_error_en(s, "posix_memalign");

               printf("posix_memalign() allocated at %p\n", sp);

               s = pthread_attr_setstack(&attr, sp, stack_size);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setstack");
           }

           s = pthread_create(&thr, attrp, &thread_start, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           if (attrp != NULL) {
               s = pthread_attr_destroy(attrp);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_destroy");
           }

           pause();    /* Terminates when other thread calls exit() */
       }

SEE ALSO
       pthread_attr_setaffinity_np(3), pthread_attr_setdetachstate(3), pthread_attr_setguardsize(3),  pthread_attr_setinher‐
       itsched(3),       pthread_attr_setschedparam(3),       pthread_attr_setschedpolicy(3),      pthread_attr_setscope(3),
       pthread_attr_setstack(3),     pthread_attr_setstackaddr(3),     pthread_attr_setstacksize(3),      pthread_create(3),
       pthread_getattr_np(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-11                                     PTHREAD_ATTR_INIT(3)
************************************************************************************************************
PTHREAD_ATTR_SETAFFINITY_NP(3)                    Linux Programmer's Manual                   PTHREAD_ATTR_SETAFFINITY_NP(3)



NAME
       pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - set/get CPU affinity attribute in thread attributes object

SYNOPSIS
       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <pthread.h>

       int pthread_attr_setaffinity_np(pthread_attr_t *attr,
                          size_t cpusetsize, const cpu_set_t *cpuset);
       int pthread_attr_getaffinity_np(pthread_attr_t *attr,
                          size_t cpusetsize, cpu_set_t *cpuset);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_attr_setaffinity_np()  function  sets  the  CPU  affinity mask attribute of the thread attributes object
       referred to by attr to the value specified in cpuset.  This attribute determines the CPU affinity mask  of  a  thread
       created using the thread attributes object attr.

       The  pthread_attr_getaffinity_np()  function  returns the CPU affinity mask attribute of the thread attributes object
       referred to by attr in the buffer pointed to by cpuset.

       The argument cpusetsize is the length (in bytes) of the buffer pointed to by cpuset.  Typically, this argument  would
       be specified as sizeof(cpu_set_t).

       For  more  details on CPU affinity masks, see sched_setaffinity(2).  For a description of a set of macros that can be
       used to manipulate and inspect CPU sets, see CPU_SET(3).

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       EINVAL (pthread_attr_setaffinity_np()) cpuset specified a CPU that was outside the set supported by the kernel.  (The
              kernel configuration option CONFIG_NR_CPUS defines the range of the set supported by the kernel data type used
              to represent CPU sets.)

       EINVAL (pthread_attr_getaffinity_np()) A CPU in the affinity mask of the thread attributes object referred to by attr
              lies outside the range specified by cpusetsize (i.e., cpuset/cpusetsize is too small).

       ENOMEM (pthread_attr_setaffinity_np()) Could not allocate memory.

VERSIONS
       These functions are provided by glibc since version 2.3.4.

CONFORMING TO
       These functions are nonstandard GNU extensions; hence the suffix "_np" (nonportable) in the names.

NOTES
       In  glibc 2.3.3 only, versions of these functions were provided that did not have a cpusetsize argument.  Instead the
       CPU set size given to the underlying system calls was always sizeof(cpu_set_t).

SEE ALSO
       sched_setaffinity(2), pthread_attr_init(3), pthread_setaffinity_np(3), cpuset(7), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-09-10                           PTHREAD_ATTR_SETAFFINITY_NP(3)
************************************************************************************************************
PTHREAD_ATTR_SETDETACHSTATE(3)                    Linux Programmer's Manual                   PTHREAD_ATTR_SETDETACHSTATE(3)



NAME
       pthread_attr_setdetachstate, pthread_attr_getdetachstate - set/get detach state attribute in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
       int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_attr_setdetachstate()  function sets the detach state attribute of the thread attributes object referred
       to by attr to the value specified in detachstate.  The detach state attribute determines  whether  a  thread  created
       using the thread attributes object attr will be created in a joinable or a detached state.

       The following values may be specified in detachstate:

       PTHREAD_CREATE_DETACHED
              Threads that are created using attr will be created in a detached state.

       PTHREAD_CREATE_JOINABLE
              Threads that are created using attr will be created in a joinable state.

       The  default  setting  of  the detach state attribute in a newly initialized thread attributes object is PTHREAD_CRE‐
       ATE_JOINABLE.

       The pthread_attr_getdetachstate() returns the detach state attribute of the thread attributes object attr in the buf‐
       fer pointed to by detachstate.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setdetachstate(3) can fail with the following error:

       EINVAL An invalid value was specified in detachstate.

CONFORMING TO
       POSIX.1-2001.

NOTES
       See pthread_create(3) for more details on detached and joinable threads.

       A  thread  that  is  created in a joinable state should eventually either be joined using pthread_join(3) or detached
       using pthread_detach(3); see pthread_create(3).

       It is an error to specify the thread ID of a thread that was  created  in  a  detached  state  in  a  later  call  to
       pthread_detach(3) or pthread_join(3).

EXAMPLE
       See pthread_attr_init(3).

SEE ALSO
       pthread_attr_init(3), pthread_create(3), pthread_detach(3), pthread_join(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-02-03                           PTHREAD_ATTR_SETDETACHSTATE(3)
************************************************************************************************************
PTHREAD_ATTR_SETGUARDSIZE(3)                      Linux Programmer's Manual                     PTHREAD_ATTR_SETGUARDSIZE(3)



NAME
       pthread_attr_setguardsize, pthread_attr_getguardsize - set/get guard size attribute in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
       int pthread_attr_getguardsize(pthread_attr_t *attr, size_t *guardsize);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_attr_setguardsize() function sets the guard size attribute of the thread attributes object referred to by
       attr to the value specified in guardsize.

       If guardsize is greater than 0, then for each new thread created using attr the system allocates an additional region
       of at least guardsize bytes at the end of the thread's stack to act as the guard area for the stack (but see BUGS).

       If guardsize is 0, then new threads created with attr will not have a guard area.

       The default guard size is the same as the system page size.

       If the stack address attribute has been set in attr (using pthread_attr_setstack(3) or pthread_attr_setstackaddr(3)),
       meaning that the caller is allocating the thread's stack, then the guard size attribute is ignored  (i.e.,  no  guard
       area  is  created  by  the system): it is the application's responsibility to handle stack overflow (perhaps by using
       mprotect(2) to manually define a guard area at the end of the stack that it has allocated).

       The pthread_attr_getguardsize() function returns the guard size attribute of the thread attributes object referred to
       by attr in the buffer pointed to by guardsize.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       POSIX.1-2001 documents an EINVAL error if attr or guardsize is invalid.  On Linux these functions always succeed (but
       portable and future-proof applications should nevertheless handle a possible error return).

VERSIONS
       These functions are provided by glibc since version 2.1.

CONFORMING TO
       POSIX.1-2001.

NOTES
       A guard area consists of virtual memory pages that are protected to prevent read and write access.  If a thread over‐
       flows  its  stack into the guard area, then, on most hard architectures, it receives a SIGSEGV signal, thus notifying
       it of the overflow.  Guard areas start on page boundaries, and the guard size is internally rounded up to the  system
       page  size when creating a thread.  (Nevertheless, pthread_attr_getguardsize() returns the guard size that was set by
       pthread_attr_setguardsize().)

       Setting a guard size of 0 may be useful to save memory in an application that creates many  threads  and  knows  that
       stack overflow can never occur.

       Choosing  a  guard size larger than the default size may be necessary for detecting stack overflows if a thread allo‐
       cates large data structures on the stack.

BUGS
       As at glibc 2.8, the NPTL threading implementation includes the guard area within the stack size  allocation,  rather
       than  allocating  extra space at the end of the stack, as POSIX.1 requires.  (This can result in an EINVAL error from
       pthread_create(3) if the guard size value is too large, leaving no space for the actual stack.)

       The obsolete LinuxThreads implementation did the right thing, allocating extra space at the end of the stack for  the
       guard area.

EXAMPLE
       See pthread_getattr_np(3).

SEE ALSO
       mmap(2),   mprotect(2),  pthread_attr_init(3),  pthread_create(3),  pthread_attr_setstack(3),  pthread_attr_setstack‐
       size(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-10-24                             PTHREAD_ATTR_SETGUARDSIZE(3)
************************************************************************************************************
PTHREAD_ATTR_SETINHERITSCHED(3)                   Linux Programmer's Manual                  PTHREAD_ATTR_SETINHERITSCHED(3)



NAME
       pthread_attr_setinheritsched, pthread_attr_getinheritsched - set/get inherit scheduler attribute in thread attributes
       object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setinheritsched(pthread_attr_t *attr,
                                        int inheritsched);
       int pthread_attr_getinheritsched(pthread_attr_t *attr,
                                        int *inheritsched);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_attr_setinheritsched() function sets the inherit scheduler attribute  of  the  thread  attributes  object
       referred  to  by  attr  to the value specified in inheritsched.  The inherit scheduler attribute determines whether a
       thread created using the thread attributes object attr will inherit its scheduling attributes from the calling thread
       or whether it will take them from attr.

       The following values may be specified in inheritsched:

       PTHREAD_INHERIT_SCHED
              Threads  that  are  created  using attr inherit scheduling attributes from the creating thread; the scheduling
              attributes in attr are ignored.

       PTHREAD_EXPLICIT_SCHED
              Threads that are created using attr take  their  scheduling  attributes  from  the  values  specified  by  the
              attributes object.

       The  default  setting  of  the  inherit  scheduler  attribute  in  a  newly  initialized  thread attributes object is
       PTHREAD_INHERIT_SCHED.

       The pthread_attr_getinheritsched() returns the inherit scheduler attribute of the thread attributes  object  attr  in
       the buffer pointed to by inheritsched.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setinheritsched() can fail with the following error:

       EINVAL Invalid value in inheritsched.

       POSIX.1-2001  also  documents  an  optional  ENOTSUP  error ("attempt was made to set the attribute to an unsupported
       value") for pthread_attr_setinheritsched().

CONFORMING TO
       POSIX.1-2001.

EXAMPLE
       See pthread_setschedparam(3).

BUGS
       As at glibc 2.8, if a thread attributes object is initialized using pthread_attr_init(3), then the scheduling  policy
       of  the  attributes  object  is  set to SCHED_OTHER and the scheduling priority is set to 0.  However, if the inherit
       scheduler attribute is then set to PTHREAD_EXPLICIT_SCHED, then a thread created using the attribute  object  wrongly
       inherits its scheduling attributes from the creating thread.  This bug does not occur if either the scheduling policy
       or scheduling priority attribute is explicitly set in the thread attributes object before calling pthread_create(3).

SEE ALSO
       sched_setscheduler(2),    pthread_attr_init(3),    pthread_attr_setschedparam(3),     pthread_attr_setschedpolicy(3),
       pthread_create(3), pthread_setschedparam(3), pthread_setschedprio(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-10                          PTHREAD_ATTR_SETINHERITSCHED(3)
************************************************************************************************************
PTHREAD_ATTR_SETSCHEDPARAM(3)                     Linux Programmer's Manual                    PTHREAD_ATTR_SETSCHEDPARAM(3)



NAME
       pthread_attr_setschedparam, pthread_attr_getschedparam - set/get scheduling parameter attributes in thread attributes
       object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setschedparam(pthread_attr_t *attr,
                                      const struct sched_param *param);
       int pthread_attr_getschedparam(pthread_attr_t *attr,
                                      struct sched_param *param);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_attr_setschedparam() function sets the scheduling parameter attributes of the  thread  attributes  object
       referred to by attr to the values specified in the buffer pointed to by param.  These attributes determine the sched‐
       uling parameters of a thread created using the thread attributes object attr.

       The pthread_attr_getschedparam() returns the scheduling parameter attributes of the thread attributes object attr  in
       the buffer pointed to by param.

       Scheduling parameters are maintained in the following structure:

           struct sched_param {
               int sched_priority;     /* Scheduling priority */
           };

       As  can be seen, only one scheduling parameter is supported.  For details of the permitted ranges for scheduling pri‐
       orities in each scheduling policy, see sched_setscheduler(2).

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       POSIX.1 documents EINVAL and ENOTSUP errors for pthread_attr_setschedparam().  On Linux these functions  always  suc‐
       ceed (but portable and future-proof applications should nevertheless handle a possible error return).

CONFORMING TO
       POSIX.1-2001.

EXAMPLE
       See pthread_setschedparam(3).

NOTES
       See pthread_attr_setschedpolicy(3) for a list of the thread scheduling policies supported on Linux.

SEE ALSO
       sched_get_priority_min(2),      sched_setscheduler(2),     pthread_attr_init(3),     pthread_attr_setinheritsched(3),
       pthread_attr_setschedpolicy(3), pthread_create(3), pthread_setschedparam(3), pthread_setschedprio(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-02-03                            PTHREAD_ATTR_SETSCHEDPARAM(3)
************************************************************************************************************
PTHREAD_ATTR_SETSCHEDPOLICY(3)                    Linux Programmer's Manual                   PTHREAD_ATTR_SETSCHEDPOLICY(3)



NAME
       pthread_attr_setschedpolicy,  pthread_attr_getschedpolicy  - set/get scheduling policy attribute in thread attributes
       object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);
       int pthread_attr_getschedpolicy(pthread_attr_t *attr, int *policy);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_attr_setschedpolicy() function sets the scheduling policy  attribute  of  the  thread  attributes  object
       referred  to  by  attr to the value specified in policy.  This attribute determines the scheduling policy of a thread
       created using the thread attributes object attr.

       The supported values for  policy  are  SCHED_FIFO,  SCHED_RR,  and  SCHED_OTHER,  with  the  semantics  described  in
       sched_setscheduler(2).

       The pthread_attr_getschedpolicy() returns the scheduling policy attribute of the thread attributes object attr in the
       buffer pointed to by policy.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setschedpolicy() can fail with the following error:

       EINVAL Invalid value in policy.

       POSIX.1-2001 also documents an optional ENOTSUP error ("attempt was made to  set  the  attribute  to  an  unsupported
       value") for pthread_attr_setschedpolicy().

CONFORMING TO
       POSIX.1-2001.

EXAMPLE
       See pthread_setschedparam(3).

SEE ALSO
       sched_setscheduler(2),    pthread_attr_init(3),    pthread_attr_setinheritsched(3),    pthread_attr_setschedparam(3),
       pthread_create(3), pthread_setschedparam(3), pthread_setschedprio(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-02-03                           PTHREAD_ATTR_SETSCHEDPOLICY(3)
************************************************************************************************************
PTHREAD_ATTR_SETSCOPE(3)                          Linux Programmer's Manual                         PTHREAD_ATTR_SETSCOPE(3)



NAME
       pthread_attr_setscope, pthread_attr_getscope - set/get contention scope attribute in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setscope(pthread_attr_t *attr, int scope);
       int pthread_attr_getscope(pthread_attr_t *attr, int *scope);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_attr_setscope() function sets the contention scope attribute of the thread attributes object referred to
       by attr to the value specified in scope.  The contention scope attribute defines the set of threads against  which  a
       thread competes for resources such as the CPU.  POSIX.1-2001 specifies two possible values for scope:

       PTHREAD_SCOPE_SYSTEM
              The  thread  competes for resources with all other threads in all processes on the system that are in the same
              scheduling allocation domain (a group of one or more processors).  PTHREAD_SCOPE_SYSTEM threads are  scheduled
              relative to one another according to their scheduling policy and priority.

       PTHREAD_SCOPE_PROCESS
              The  thread  competes for resources with all other threads in the same process that were also created with the
              PTHREAD_SCOPE_PROCESS contention scope.  PTHREAD_SCOPE_PROCESS threads are scheduled relative to other threads
              in  the  process  according  to  their scheduling policy and priority.  POSIX.1-2001 leaves it unspecified how
              these threads contend with other threads in other process on the system or with  other  threads  in  the  same
              process that were created with the PTHREAD_SCOPE_SYSTEM contention scope.

       POSIX.1-2001 only requires that an implementation support one of these contention scopes, but permits both to be sup‐
       ported.  Linux supports PTHREAD_SCOPE_SYSTEM, but not PTHREAD_SCOPE_PROCESS.

       The pthread_attr_getscope() function returns the contention scope attribute of the thread attributes object  referred
       to by attr in the buffer pointed to by scope.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setscope() can fail with the following errors:

       EINVAL An invalid value was specified in scope.

       ENOTSUP
              scope specified the value PTHREAD_SCOPE_PROCESS, which is not supported on Linux.

CONFORMING TO
       POSIX.1-2001.

NOTES
       The  PTHREAD_SCOPE_SYSTEM  contention scope typically indicates that a userspace thread is bound directly to a single
       kernel-scheduling entity.  This is the case on Linux for the obsolete LinuxThreads implementation and the modern NPTL
       implementation, which are both 1:1 threading implementations.

       POSIX.1-2001 specifies that the default contention scope is implementation-defined.

SEE ALSO
       pthread_attr_init(3), pthread_attr_setaffinity_np(3), pthread_attr_setinheritsched(3), pthread_attr_setschedparam(3),
       pthread_attr_setschedpolicy(3), pthread_create(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-10-24                                 PTHREAD_ATTR_SETSCOPE(3)
************************************************************************************************************
PTHREAD_ATTR_SETSTACK(3)                          Linux Programmer's Manual                         PTHREAD_ATTR_SETSTACK(3)



NAME
       pthread_attr_setstack, pthread_attr_getstack - set/get stack attributes in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setstack(pthread_attr_t *attr,
                                 void *stackaddr, size_t stacksize);
       int pthread_attr_getstack(pthread_attr_t *attr,
                                 void **stackaddr, size_t *stacksize);

       Compile and link with -pthread.

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pthread_attr_getstack(), pthread_attr_setstack():
           _POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600

DESCRIPTION
       The pthread_attr_setstack() function sets the stack address and stack size attributes of the thread attributes object
       referred to by attr to the values specified in stackaddr and stacksize, respectively.  These attributes  specify  the
       location  and  size  of  the stack that should be used by a thread that is created using the thread attributes object
       attr.

       stackaddr should point to the lowest addressable byte of a buffer of stacksize bytes that was allocated by the  call‐
       er.  The pages of the allocated buffer should be both readable and writable.

       The  pthread_attr_getstack()  function  returns  the stack address and stack size attributes of the thread attributes
       object referred to by attr in the buffers pointed to by stackaddr and stacksize, respectively.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setstack() can fail with the following error:

       EINVAL stacksize is less than PTHREAD_STACK_MIN (16384) bytes.  On some systems, this error may also occur if  stack‐
              addr or stackaddr + stacksize is not suitably aligned.

       POSIX.1-2001  also documents an EACCES error if the stack area described by stackaddr and stacksize is not both read‐
       able and writable by the caller.

VERSIONS
       These functions are provided by glibc since version 2.2.

CONFORMING TO
       POSIX.1-2001.

NOTES
       These functions are provided for applications that must ensure that a thread's stack is placed in a particular  loca‐
       tion.   For  most  applications,  this  is  not  necessary,  and  the use of these functions should be avoided.  (Use
       pthread_attr_setstacksize(3) if an application simply requires a stack size other than the default.)

       When an application employs pthread_attr_setstack(), it takes over the responsibility of allocating the  stack.   Any
       guard size value that was set using pthread_attr_setguardsize(3) is ignored.  If deemed necessary, it is the applica‐
       tion's responsibility to allocate a guard area (one or more pages protected against reading and  writing)  to  handle
       the possibility of stack overflow.

       The  address  specified  in  stackaddr  should be suitably aligned: for full portability, align it on a page boundary
       (sysconf(_SC_PAGESIZE)).  posix_memalign(3) may be useful for allocation.  Probably, stacksize should also be a  mul‐
       tiple of the system page size.

       If  attr is used to create multiple threads, then the caller must change the stack address attribute between calls to
       pthread_create(3); otherwise, the threads will attempt to use the same memory area for their stacks, and  chaos  will
       ensue.

EXAMPLE
       See pthread_attr_init(3).

SEE ALSO
       mmap(2),  mprotect(2),  posix_memalign(3), pthread_attr_init(3), pthread_attr_setguardsize(3), pthread_attr_setstack‐
       addr(3), pthread_attr_setstacksize(3), pthread_create(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-10-24                                 PTHREAD_ATTR_SETSTACK(3)
************************************************************************************************************
PTHREAD_ATTR_SETSTACKADDR(3)                      Linux Programmer's Manual                     PTHREAD_ATTR_SETSTACKADDR(3)



NAME
       pthread_attr_setstackaddr, pthread_attr_getstackaddr - set/get stack address attribute in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr);
       int pthread_attr_getstackaddr(pthread_attr_t *attr, void **stackaddr);

       Compile and link with -pthread.

DESCRIPTION
       These functions are obsolete: do not use them.  Use pthread_attr_setstack(3) and pthread_attr_getstack(3) instead.

       The pthread_attr_setstackaddr() function sets the stack address attribute of the thread attributes object referred to
       by attr to the value specified in stackaddr.  This attribute specifies the location of the stack that should be  used
       by a thread that is created using the thread attributes object attr.

       stackaddr  should  point to a buffer of at least PTHREAD_STACK_MIN bytes that was allocated by the caller.  The pages
       of the allocated buffer should be both readable and writable.

       The pthread_attr_getstackaddr() function returns the stack address attribute of the thread attributes object referred
       to by attr in the buffer pointed to by stackaddr.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       No errors are defined (but applications should nevertheless handle a possible error return).

VERSIONS
       These functions are provided by glibc since version 2.1.

CONFORMING TO
       POSIX.1-2001  specifies  these functions but marks them as obsolete.  POSIX.1-2008 removes the specification of these
       functions.

NOTES
       Do not use these functions!  They cannot be portably used, since they provide no way of specifying the  direction  of
       growth  or the range of the stack.  For example, on architectures with a stack that grows downwards, stackaddr speci‐
       fies the next address past the highest address of the allocated stack area.  However, on architectures with  a  stack
       that  grows  upwards, stackaddr specifies the lowest address in the allocated stack area.  By contrast, the stackaddr
       used by pthread_attr_setstack(3) and pthread_attr_getstack(3), is always a pointer to the lowest address in the allo‐
       cated stack area (and the stacksize argument specifies the range of the stack).

SEE ALSO
       pthread_attr_init(3), pthread_attr_setstack(3), pthread_attr_setstacksize(3), pthread_create(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-10-24                             PTHREAD_ATTR_SETSTACKADDR(3)
************************************************************************************************************
PTHREAD_ATTR_SETSTACKSIZE(3)                      Linux Programmer's Manual                     PTHREAD_ATTR_SETSTACKSIZE(3)



NAME
       pthread_attr_setstacksize, pthread_attr_getstacksize - set/get stack size attribute in thread attributes object

SYNOPSIS
       #include <pthread.h>

       int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
       int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_attr_setstacksize() function sets the stack size attribute of the thread attributes object referred to by
       attr to the value specified in stacksize.

       The stack size attribute determines the minimum size (in bytes) that will be allocated for threads created using  the
       thread attributes object attr.

       The pthread_attr_getstacksize() function returns the stack size attribute of the thread attributes object referred to
       by attr in the buffer pointed to by stacksize.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       pthread_attr_setstacksize() can fail with the following error:

       EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes.

       On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not  a  multiple  of  the
       system page size.

VERSIONS
       These functions are provided by glibc since version 2.1.

CONFORMING TO
       POSIX.1-2001.

EXAMPLE
       See pthread_create(3).

NOTES
       For details on the default stack size of new threads, see pthread_create(3).

       A thread's stack size is fixed at the time of thread creation.  Only the main thread can dynamically grow its stack.

       The  pthread_attr_setstack(3)  function allows an application to set both the size and location of a caller-allocated
       stack that is to be used by a thread.

BUGS
       As at glibc 2.8, if the specified stacksize is not a multiple of STACK_ALIGN (16 bytes on most architectures), it may
       be  rounded  downwards,  in violation of POSIX.1-2001, which says that the allocated stack will be at least stacksize
       bytes.

SEE ALSO
       getrlimit(2),  pthread_attr_init(3),   pthread_attr_setguardsize(3),   pthread_attr_setstack(3),   pthread_create(3),
       pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-05                             PTHREAD_ATTR_SETSTACKSIZE(3)
************************************************************************************************************
PTHREAD_CANCEL(3)                                 Linux Programmer's Manual                                PTHREAD_CANCEL(3)



NAME
       pthread_cancel - send a cancellation request to a thread

SYNOPSIS
       #include <pthread.h>

       int pthread_cancel(pthread_t thread);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_cancel() function sends a cancellation request to the thread thread.  Whether and when the target thread
       reacts to the cancellation request depends on two attributes that are under the control of that thread: its  cancela‐
       bility state and type.

       A thread's cancelability state, determined by pthread_setcancelstate(3), can be enabled (the default for new threads)
       or disabled.  If a thread has disabled cancellation, then a cancellation request  remains  queued  until  the  thread
       enables cancellation.  If a thread has enabled cancellation, then its cancelability type determines when cancellation
       occurs.

       A thread's cancellation type, determined by pthread_setcanceltype(3), may be either  asynchronous  or  deferred  (the
       default  for  new  threads).   Asynchronous  cancelability means that the thread can be canceled at any time (usually
       immediately, but the system does not guarantee this).  Deferred cancelability means that cancellation will be delayed
       until  the thread next calls a function that is a cancellation point.  A list of functions that are or may be cancel‐
       lation points is provided in pthreads(7).

       When a cancellation requested is acted on, the following steps occur for thread (in this order):

       1. Cancellation clean-up handlers are popped (in the reverse of the order in which  they  were  pushed)  and  called.
          (See pthread_cleanup_push(3).)

       2. Thread-specific data destructors are called, in an unspecified order.  (See pthread_key_create(3).)

       3. The thread is terminated.  (See pthread_exit(3).)

       The  above  steps  happen asynchronously with respect to the pthread_cancel() call; the return status of pthread_can‐
       cel() merely informs the caller whether the cancellation request was successfully queued.

       After a canceled thread has terminated, a join with that thread using pthread_join(3) obtains PTHREAD_CANCELED as the
       thread's exit status.  (Joining with a thread is the only way to know that cancellation has completed.)

RETURN VALUE
       On success, pthread_cancel() returns 0; on error, it returns a nonzero error number.

ERRORS
       ESRCH  No thread with the ID thread could be found.

CONFORMING TO
       POSIX.1-2001.

NOTES
       On  Linux,  cancellation  is implemented using signals.  Under the NPTL threading implementation, the first real-time
       signal (i.e., signal 32) is used for this purpose.  On LinuxThreads, the second real-time signal is  used,  if  real-
       time signals are available, otherwise SIGUSR2 is used.

EXAMPLE
       The program below creates a thread and then cancels it.  The main thread joins with the canceled thread to check that
       its exit status was PTHREAD_CANCELED.  The following shell session shows what happens when we run the program:

           $ ./a.out
           thread_func(): started; cancellation disabled
           main(): sending cancellation request
           thread_func(): about to enable cancellation
           main(): thread was canceled

   Program source

       #include <pthread.h>
       #include <stdio.h>
       #include <errno.h>
       #include <stdlib.h>
       #include <unistd.h>

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       static void *
       thread_func(void *ignored_argument)
       {
           int s;

           /* Disable cancellation for a while, so that we don't
              immediately react to a cancellation request */

           s = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_setcancelstate");

           printf("thread_func(): started; cancellation disabled\n");
           sleep(5);
           printf("thread_func(): about to enable cancellation\n");

           s = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_setcancelstate");

           /* sleep() is a cancellation point */

           sleep(1000);        /* Should get canceled while we sleep */

           /* Should never get here */

           printf("thread_func(): not canceled!\n");
           return NULL;
       }

       int
       main(void)
       {
           pthread_t thr;
           void *res;
           int s;

           /* Start a thread and then send it a cancellation request */

           s = pthread_create(&thr, NULL, &thread_func, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           sleep(2);           /* Give thread a chance to get started */

           printf("main(): sending cancellation request\n");
           s = pthread_cancel(thr);
           if (s != 0)
               handle_error_en(s, "pthread_cancel");

           /* Join with thread to see what its exit status was */

           s = pthread_join(thr, &res);
           if (s != 0)
               handle_error_en(s, "pthread_join");

           if (res == PTHREAD_CANCELED)
               printf("main(): thread was canceled\n");
           else
               printf("main(): thread wasn't canceled (shouldn't happen!)\n");
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       pthread_cleanup_push(3), pthread_create(3),  pthread_exit(3),  pthread_join(3),  pthread_key_create(3),  pthread_set‐
       cancelstate(3), pthread_setcanceltype(3), pthread_testcancel(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-17                                        PTHREAD_CANCEL(3)
************************************************************************************************************
PTHREAD_CLEANUP_PUSH(3)                           Linux Programmer's Manual                          PTHREAD_CLEANUP_PUSH(3)



NAME
       pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation clean-up handlers

SYNOPSIS
       #include <pthread.h>

       void pthread_cleanup_push(void (*routine)(void *),
                                 void *arg);
       void pthread_cleanup_pop(int execute);

       Compile and link with -pthread.

DESCRIPTION
       These  functions  manipulate the calling thread's stack of thread-cancellation clean-up handlers.  A clean-up handler
       is a function that is automatically executed when a thread is canceled (or in various other  circumstances  described
       below); it might, for example, unlock a mutex so that it becomes available to other threads in the process.

       The  pthread_cleanup_push()  function pushes routine onto the top of the stack of clean-up handlers.  When routine is
       later invoked, it will be given arg as its argument.

       The pthread_cleanup_pop() function removes the routine at the top of the stack of clean-up handlers,  and  optionally
       executes it if execute is nonzero.

       A cancellation clean-up handler is popped from the stack and executed in the following circumstances:

       1. When  a  thread  is  canceled,  all of the stacked clean-up handlers are popped and executed in the reverse of the
          order in which they were pushed onto the stack.

       2. When a thread terminates by calling pthread_exit(3), all clean-up handlers are executed as described in  the  pre‐
          ceding  point.   (Clean-up handlers are not called if the thread terminates by performing a return from the thread
          start function.)

       3. When a thread calls pthread_cleanup_pop() with a nonzero execute argument, the top-most clean-up handler is popped
          and executed.

       POSIX.1 permits pthread_cleanup_push() and pthread_cleanup_pop() to be implemented as macros that expand to text con‐
       taining '{' and '}', respectively.  For this reason, the caller must ensure that calls to these functions are  paired
       within  the same function, and at the same lexical nesting level.  (In other words, a clean-up handler is only estab‐
       lished during the execution of a specified section of code.)

       Calling longjmp(3) (siglongjmp(3)) produces undefined results if any call has been made to pthread_cleanup_push()  or
       pthread_cleanup_pop()  without  the  matching  call  of  the  pair  since  the  jump  buffer  was filled by setjmp(3)
       (sigsetjmp(3)).  Likewise, calling longjmp(3) (siglongjmp(3)) from  inside  a  clean-up  handler  produces  undefined
       results unless the jump buffer was also filled by setjmp(3) (sigsetjmp(3)) inside the handler.

RETURN VALUE
       These functions do not return a value.

ERRORS
       There are no errors.

CONFORMING TO
       POSIX.1-2001.

NOTES
       On  Linux,  the  pthread_cleanup_push()  and pthread_cleanup_pop() functions are implemented as macros that expand to
       text containing '{' and '}', respectively.  This means that variables declared within the scope of  paired  calls  to
       these functions will only be visible within that scope.

       POSIX.1  says  that  the  effect  of  using  return,  break, continue, or goto to prematurely leave a block bracketed
       pthread_cleanup_push() and pthread_cleanup_pop() is undefined.  Portable applications should avoid doing this.

EXAMPLE
       The program below provides a simple example of the use of the functions described in this page.  The program  creates
       a  thread that executes a loop bracketed by pthread_cleanup_push() and pthread_cleanup_pop().  This loop increments a
       global variable, cnt, once each second.  Depending on what command-line arguments are supplied, the main thread sends
       the  other thread a cancellation request, or sets a global variable that causes the other thread to exit its loop and
       terminate normally (by doing a return).

       In the following shell session, the main thread sends a cancellation request to the other thread:

           $ ./a.out
           New thread started
           cnt = 0
           cnt = 1
           Canceling thread
           Called clean-up handler
           Thread was canceled; cnt = 0

       From the above, we see that the thread was canceled, and that the cancellation clean-up handler  was  called  and  it
       reset the value of the global variable cnt to 0.

       In the next run, the main program sets a global variable that causes other thread to terminate normally:

           $ ./a.out x
           New thread started
           cnt = 0
           cnt = 1
           Thread terminated normally; cnt = 2

       From  the above, we see that the clean-up handler was not executed (because cleanup_pop_arg was 0), and therefore the
       value of cnt was not reset.

       In the next run, the main program sets a global variable that causes the other thread to terminate normally, and sup‐
       plies a nonzero value for cleanup_pop_arg:

           $ ./a.out x 1
           New thread started
           cnt = 0
           cnt = 1
           Called clean-up handler
           Thread terminated normally; cnt = 0

       In  the above, we see that although the thread was not canceled, the clean-up handler was executed, because the argu‐
       ment given to pthread_cleanup_pop() was nonzero.

   Program source

       #include <pthread.h>
       #include <sys/types.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <errno.h>

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       static int done = 0;
       static int cleanup_pop_arg = 0;
       static int cnt = 0;

       static void
       cleanup_handler(void *arg)
       {
           printf("Called clean-up handler\n");
           cnt = 0;
       }

       static void *
       thread_start(void *arg)
       {
           time_t start, curr;

           printf("New thread started\n");

           pthread_cleanup_push(cleanup_handler, NULL);

           curr = start = time(NULL);

           while (!done) {
               pthread_testcancel();           /* A cancellation point */
               if (curr < time(NULL)) {
                   curr = time(NULL);
                   printf("cnt = %d\n", cnt);  /* A cancellation point */
                   cnt++;
               }
           }

           pthread_cleanup_pop(cleanup_pop_arg);
           return NULL;
       }

       int
       main(int argc, char *argv[])
       {
           pthread_t thr;
           int s;
           void *res;

           s = pthread_create(&thr, NULL, thread_start, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           sleep(2);           /* Allow new thread to run a while */

           if (argc > 1) {
               if (argc > 2)
                   cleanup_pop_arg = atoi(argv[2]);
               done = 1;

           } else {
               printf("Canceling thread\n");
               s = pthread_cancel(thr);
               if (s != 0)
                   handle_error_en(s, "pthread_cancel");
           }

           s = pthread_join(thr, &res);
           if (s != 0)
               handle_error_en(s, "pthread_join");

           if (res == PTHREAD_CANCELED)
               printf("Thread was canceled; cnt = %d\n", cnt);
           else
               printf("Thread terminated normally; cnt = %d\n", cnt);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       pthread_cancel(3), pthread_cleanup_push_defer_np(3), pthread_setcancelstate(3), pthread_testcancel(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-24                                  PTHREAD_CLEANUP_PUSH(3)
************************************************************************************************************
PTHREAD_CLEANUP_PUSH_DEFER_NP(3)                  Linux Programmer's Manual                 PTHREAD_CLEANUP_PUSH_DEFER_NP(3)



NAME
       pthread_cleanup_push_defer_np,  pthread_cleanup_pop_restore_np  -  push and pop thread cancellation clean-up handlers
       while saving cancelability type

SYNOPSIS
       #include <pthread.h>

       void pthread_cleanup_push_defer_np(void (*routine)(void *),
                                          void *arg);
       void pthread_cleanup_pop_restore_np(int execute);

       Compile and link with -pthread.

DESCRIPTION
       These functions are the same as pthread_cleanup_push(3) and pthread_cleanup_pop(3), except for the differences  noted
       on this page.

       Like  pthread_cleanup_push(3), pthread_cleanup_push_defer_np() pushes routine onto the thread's stack of cancellation
       clean-up handlers.  In addition, it also saves the thread's current cancelability type, and  sets  the  cancelability
       type  to  "deferred"  (see  pthread_setcanceltype(3)); this ensures that cancellation clean-up will occur even if the
       thread's cancelability type was "asynchronous" before the the call.

       Like pthread_cleanup_pop(3), pthread_cleanup_pop_restore_np() pops the top-most clean-up handler  from  the  thread's
       stack  of  cancellation  clean-up handlers.  In addition, it restores the thread's cancelability type to its value at
       the time of the matching pthread_cleanup_push_defer_np().

       The caller must ensure that calls to these functions are paired within the same function, and  at  the  same  lexical
       nesting level.  Other restrictions apply, as described in pthread_cleanup_push(3).

       This sequence of calls:

           pthread_cleanup_push_defer_np(routine, arg);
           pthread_cleanup_pop_restore_np(execute);

       is equivalent to (but shorter and more efficient than):

           int oldtype;

           pthread_cleanup_push(routine, arg);
           pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);
           ...
           pthread_setcanceltype(oldtype, NULL);
           pthread_cleanup_pop(execute);

CONFORMING TO
       These functions are nonstandard GNU extensions; hence the suffix "_np" (nonportable) in the names.

SEE ALSO
       pthread_cancel(3), pthread_cleanup_push(3), pthread_setcancelstate(3), pthread_testcancel(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-12-04                         PTHREAD_CLEANUP_PUSH_DEFER_NP(3)
************************************************************************************************************
PTHREAD_CLEANUP_PUSH(3)                           Linux Programmer's Manual                          PTHREAD_CLEANUP_PUSH(3)



NAME
       pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation clean-up handlers

SYNOPSIS
       #include <pthread.h>

       void pthread_cleanup_push(void (*routine)(void *),
                                 void *arg);
       void pthread_cleanup_pop(int execute);

       Compile and link with -pthread.

DESCRIPTION
       These  functions  manipulate the calling thread's stack of thread-cancellation clean-up handlers.  A clean-up handler
       is a function that is automatically executed when a thread is canceled (or in various other  circumstances  described
       below); it might, for example, unlock a mutex so that it becomes available to other threads in the process.

       The  pthread_cleanup_push()  function pushes routine onto the top of the stack of clean-up handlers.  When routine is
       later invoked, it will be given arg as its argument.

       The pthread_cleanup_pop() function removes the routine at the top of the stack of clean-up handlers,  and  optionally
       executes it if execute is nonzero.

       A cancellation clean-up handler is popped from the stack and executed in the following circumstances:

       1. When  a  thread  is  canceled,  all of the stacked clean-up handlers are popped and executed in the reverse of the
          order in which they were pushed onto the stack.

       2. When a thread terminates by calling pthread_exit(3), all clean-up handlers are executed as described in  the  pre‐
          ceding  point.   (Clean-up handlers are not called if the thread terminates by performing a return from the thread
          start function.)

       3. When a thread calls pthread_cleanup_pop() with a nonzero execute argument, the top-most clean-up handler is popped
          and executed.

       POSIX.1 permits pthread_cleanup_push() and pthread_cleanup_pop() to be implemented as macros that expand to text con‐
       taining '{' and '}', respectively.  For this reason, the caller must ensure that calls to these functions are  paired
       within  the same function, and at the same lexical nesting level.  (In other words, a clean-up handler is only estab‐
       lished during the execution of a specified section of code.)

       Calling longjmp(3) (siglongjmp(3)) produces undefined results if any call has been made to pthread_cleanup_push()  or
       pthread_cleanup_pop()  without  the  matching  call  of  the  pair  since  the  jump  buffer  was filled by setjmp(3)
       (sigsetjmp(3)).  Likewise, calling longjmp(3) (siglongjmp(3)) from  inside  a  clean-up  handler  produces  undefined
       results unless the jump buffer was also filled by setjmp(3) (sigsetjmp(3)) inside the handler.

RETURN VALUE
       These functions do not return a value.

ERRORS
       There are no errors.

CONFORMING TO
       POSIX.1-2001.

NOTES
       On  Linux,  the  pthread_cleanup_push()  and pthread_cleanup_pop() functions are implemented as macros that expand to
       text containing '{' and '}', respectively.  This means that variables declared within the scope of  paired  calls  to
       these functions will only be visible within that scope.

       POSIX.1  says  that  the  effect  of  using  return,  break, continue, or goto to prematurely leave a block bracketed
       pthread_cleanup_push() and pthread_cleanup_pop() is undefined.  Portable applications should avoid doing this.

EXAMPLE
       The program below provides a simple example of the use of the functions described in this page.  The program  creates
       a  thread that executes a loop bracketed by pthread_cleanup_push() and pthread_cleanup_pop().  This loop increments a
       global variable, cnt, once each second.  Depending on what command-line arguments are supplied, the main thread sends
       the  other thread a cancellation request, or sets a global variable that causes the other thread to exit its loop and
       terminate normally (by doing a return).

       In the following shell session, the main thread sends a cancellation request to the other thread:

           $ ./a.out
           New thread started
           cnt = 0
           cnt = 1
           Canceling thread
           Called clean-up handler
           Thread was canceled; cnt = 0

       From the above, we see that the thread was canceled, and that the cancellation clean-up handler  was  called  and  it
       reset the value of the global variable cnt to 0.

       In the next run, the main program sets a global variable that causes other thread to terminate normally:

           $ ./a.out x
           New thread started
           cnt = 0
           cnt = 1
           Thread terminated normally; cnt = 2

       From  the above, we see that the clean-up handler was not executed (because cleanup_pop_arg was 0), and therefore the
       value of cnt was not reset.

       In the next run, the main program sets a global variable that causes the other thread to terminate normally, and sup‐
       plies a nonzero value for cleanup_pop_arg:

           $ ./a.out x 1
           New thread started
           cnt = 0
           cnt = 1
           Called clean-up handler
           Thread terminated normally; cnt = 0

       In  the above, we see that although the thread was not canceled, the clean-up handler was executed, because the argu‐
       ment given to pthread_cleanup_pop() was nonzero.

   Program source

       #include <pthread.h>
       #include <sys/types.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <errno.h>

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       static int done = 0;
       static int cleanup_pop_arg = 0;
       static int cnt = 0;

       static void
       cleanup_handler(void *arg)
       {
           printf("Called clean-up handler\n");
           cnt = 0;
       }

       static void *
       thread_start(void *arg)
       {
           time_t start, curr;

           printf("New thread started\n");

           pthread_cleanup_push(cleanup_handler, NULL);

           curr = start = time(NULL);

           while (!done) {
               pthread_testcancel();           /* A cancellation point */
               if (curr < time(NULL)) {
                   curr = time(NULL);
                   printf("cnt = %d\n", cnt);  /* A cancellation point */
                   cnt++;
               }
           }

           pthread_cleanup_pop(cleanup_pop_arg);
           return NULL;
       }

       int
       main(int argc, char *argv[])
       {
           pthread_t thr;
           int s;
           void *res;

           s = pthread_create(&thr, NULL, thread_start, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           sleep(2);           /* Allow new thread to run a while */

           if (argc > 1) {
               if (argc > 2)
                   cleanup_pop_arg = atoi(argv[2]);
               done = 1;

           } else {
               printf("Canceling thread\n");
               s = pthread_cancel(thr);
               if (s != 0)
                   handle_error_en(s, "pthread_cancel");
           }

           s = pthread_join(thr, &res);
           if (s != 0)
               handle_error_en(s, "pthread_join");

           if (res == PTHREAD_CANCELED)
               printf("Thread was canceled; cnt = %d\n", cnt);
           else
               printf("Thread terminated normally; cnt = %d\n", cnt);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       pthread_cancel(3), pthread_cleanup_push_defer_np(3), pthread_setcancelstate(3), pthread_testcancel(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-24                                  PTHREAD_CLEANUP_PUSH(3)
************************************************************************************************************
PTHREAD_CLEANUP_PUSH_DEFER_NP(3)                  Linux Programmer's Manual                 PTHREAD_CLEANUP_PUSH_DEFER_NP(3)



NAME
       pthread_cleanup_push_defer_np,  pthread_cleanup_pop_restore_np  -  push and pop thread cancellation clean-up handlers
       while saving cancelability type

SYNOPSIS
       #include <pthread.h>

       void pthread_cleanup_push_defer_np(void (*routine)(void *),
                                          void *arg);
       void pthread_cleanup_pop_restore_np(int execute);

       Compile and link with -pthread.

DESCRIPTION
       These functions are the same as pthread_cleanup_push(3) and pthread_cleanup_pop(3), except for the differences  noted
       on this page.

       Like  pthread_cleanup_push(3), pthread_cleanup_push_defer_np() pushes routine onto the thread's stack of cancellation
       clean-up handlers.  In addition, it also saves the thread's current cancelability type, and  sets  the  cancelability
       type  to  "deferred"  (see  pthread_setcanceltype(3)); this ensures that cancellation clean-up will occur even if the
       thread's cancelability type was "asynchronous" before the the call.

       Like pthread_cleanup_pop(3), pthread_cleanup_pop_restore_np() pops the top-most clean-up handler  from  the  thread's
       stack  of  cancellation  clean-up handlers.  In addition, it restores the thread's cancelability type to its value at
       the time of the matching pthread_cleanup_push_defer_np().

       The caller must ensure that calls to these functions are paired within the same function, and  at  the  same  lexical
       nesting level.  Other restrictions apply, as described in pthread_cleanup_push(3).

       This sequence of calls:

           pthread_cleanup_push_defer_np(routine, arg);
           pthread_cleanup_pop_restore_np(execute);

       is equivalent to (but shorter and more efficient than):

           int oldtype;

           pthread_cleanup_push(routine, arg);
           pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);
           ...
           pthread_setcanceltype(oldtype, NULL);
           pthread_cleanup_pop(execute);

CONFORMING TO
       These functions are nonstandard GNU extensions; hence the suffix "_np" (nonportable) in the names.

SEE ALSO
       pthread_cancel(3), pthread_cleanup_push(3), pthread_setcancelstate(3), pthread_testcancel(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-12-04                         PTHREAD_CLEANUP_PUSH_DEFER_NP(3)
************************************************************************************************************
PTHREAD_CREATE(3)                                 Linux Programmer's Manual                                PTHREAD_CREATE(3)



NAME
       pthread_create - create a new thread

SYNOPSIS
       #include <pthread.h>

       int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_create() function starts a new thread in the calling process.  The new thread starts execution by invok‐
       ing start_routine(); arg is passed as the sole argument of start_routine().

       The new thread terminates in one of the following ways:

       * It calls pthread_exit(3), specifying an exit status value that is available to another thread in the  same  process
         that calls pthread_join(3).

       * It  returns  from  start_routine().   This  is equivalent to calling pthread_exit(3) with the value supplied in the
         return statement.

       * It is canceled (see pthread_cancel(3)).

       * Any of the threads in the process calls exit(3), or the main thread performs a return from main().  This causes the
         termination of all threads in the process.

       The  attr  argument points to a pthread_attr_t structure whose contents are used at thread creation time to determine
       attributes for the new thread; this structure is initialized using pthread_attr_init(3) and  related  functions.   If
       attr is NULL, then the thread is created with default attributes.

       Before  returning,  a successful call to pthread_create() stores the ID of the new thread in the buffer pointed to by
       thread; this identifier is used to refer to the thread in subsequent calls to other pthreads functions.

       The new thread inherits a copy of the creating thread's signal mask (pthread_sigmask(3)).  The set of pending signals
       for  the new thread is empty (sigpending(2)).  The new thread does not inherit the creating thread's alternate signal
       stack (sigaltstack(2)).

       The new thread inherits the calling thread's floating-point environment (fenv(3)).

       The initial value of the new thread's CPU-time clock is 0 (see pthread_getcpuclockid(3)).

   Linux-specific details
       The new thread inherits copies of the calling thread's capability sets (see capabilities(7)) and  CPU  affinity  mask
       (see sched_setaffinity(2)).

RETURN VALUE
       On  success,  pthread_create() returns 0; on error, it returns an error number, and the contents of *thread are unde‐
       fined.

ERRORS
       EAGAIN Insufficient resources to create another thread, or a system-imposed  limit  on  the  number  of  threads  was
              encountered.   The  latter  case  may  occur  in two ways: the RLIMIT_NPROC soft resource limit (set via setr‐
              limit(2)), which limits the number of process for a real user ID, was reached;  or  the  kernel's  system-wide
              limit on the number of threads, /proc/sys/kernel/threads-max, was reached.

       EINVAL Invalid settings in attr.

       EPERM  No permission to set the scheduling policy and parameters specified in attr.

CONFORMING TO
       POSIX.1-2001.

NOTES
       See  pthread_self(3)  for further information on the thread ID returned in *thread by pthread_create().  Unless real-
       time scheduling policies are being employed, after a call to pthread_create(), it is indeterminate  which  thread—the
       caller or the new thread—will next execute.

       A  thread  may either be joinable or detached.  If a thread is joinable, then another thread can call pthread_join(3)
       to wait for the thread to terminate and fetch its exit status.  Only when  a  terminated  joinable  thread  has  been
       joined  are  the last of its resources released back to the system.  When a detached thread terminates, its resources
       are automatically released back to the system: it is not possible to join with the thread in order to obtain its exit
       status.   Making  a thread detached is useful for some types of daemon threads whose exit status the application does
       not need to care about.  By default, a new thread is created in a joinable state, unless attr was set to  create  the
       thread in a detached state (using pthread_attr_setdetachstate(3)).

       On Linux/x86-32, the default stack size for a new thread is 2 megabytes.  Under the NPTL threading implementation, if
       the RLIMIT_STACK soft resource limit at the time the program started has any value other than  "unlimited",  then  it
       determines  the  default stack size of new threads.  Using pthread_attr_setstacksize(3), the stack size attribute can
       be explicitly set in the attr argument used to create a thread, in order to  obtain  a  stack  size  other  than  the
       default.

EXAMPLE
       The  program  below  demonstrates the use of pthread_create(), as well as a number of other functions in the pthreads
       API.

       In the following run, on a system providing the NPTL threading implementation, the stack size defaults to  the  value
       given by the "stack size" resource limit:

           $ ulimit -s
           8192            # The stack size limit is 8 MB (0x80000 bytes)
           $ ./a.out hola salut servus
           Thread 1: top of stack near 0xb7dd03b8; argv_string=hola
           Thread 2: top of stack near 0xb75cf3b8; argv_string=salut
           Thread 3: top of stack near 0xb6dce3b8; argv_string=servus
           Joined with thread 1; returned value was HOLA
           Joined with thread 2; returned value was SALUT
           Joined with thread 3; returned value was SERVUS

       In the next run, the program explicitly sets a stack size of 1MB (using pthread_attr_setstacksize(3)) for the created
       threads:

           $ ./a.out -s 0x100000 hola salut servus
           Thread 1: top of stack near 0xb7d723b8; argv_string=hola
           Thread 2: top of stack near 0xb7c713b8; argv_string=salut
           Thread 3: top of stack near 0xb7b703b8; argv_string=servus
           Joined with thread 1; returned value was HOLA
           Joined with thread 2; returned value was SALUT
           Joined with thread 3; returned value was SERVUS

   Program source

       #include <pthread.h>
       #include <string.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <errno.h>
       #include <ctype.h>

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       #define handle_error(msg) \
               do { perror(msg); exit(EXIT_FAILURE); } while (0)

       struct thread_info {    /* Used as argument to thread_start() */
           pthread_t thread_id;        /* ID returned by pthread_create() */
           int       thread_num;       /* Application-defined thread # */
           char     *argv_string;      /* From command-line argument */
       };

       /* Thread start function: display address near top of our stack,
          and return upper-cased copy of argv_string */

       static void *
       thread_start(void *arg)
       {
           struct thread_info *tinfo = (struct thread_info *) arg;
           char *uargv, *p;

           printf("Thread %d: top of stack near %p; argv_string=%s\n",
                   tinfo->thread_num, &p, tinfo->argv_string);

           uargv = strdup(tinfo->argv_string);
           if (uargv == NULL)
               handle_error("strdup");

           for (p = uargv; *p != '\0'; p++)
               *p = toupper(*p);

           return uargv;
       }

       int
       main(int argc, char *argv[])
       {
           int s, tnum, opt, num_threads;
           struct thread_info *tinfo;
           pthread_attr_t attr;
           int stack_size;
           void *res;

           /* The "-s" option specifies a stack size for our threads */

           stack_size = -1;
           while ((opt = getopt(argc, argv, "s:")) != -1) {
               switch (opt) {
               case 's':
                   stack_size = strtoul(optarg, NULL, 0);
                   break;

               default:
                   fprintf(stderr, "Usage: %s [-s stack-size] arg...\n",
                           argv[0]);
                   exit(EXIT_FAILURE);
               }
           }

           num_threads = argc - optind;

           /* Initialize thread creation attributes */

           s = pthread_attr_init(&attr);
           if (s != 0)
               handle_error_en(s, "pthread_attr_init");

           if (stack_size > 0) {
               s = pthread_attr_setstacksize(&attr, stack_size);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setstacksize");
           }

           /* Allocate memory for pthread_create() arguments */

           tinfo = calloc(num_threads, sizeof(struct thread_info));
           if (tinfo == NULL)
               handle_error("calloc");

           /* Create one thread for each command-line argument */

           for (tnum = 0; tnum < num_threads; tnum++) {
               tinfo[tnum].thread_num = tnum + 1;
               tinfo[tnum].argv_string = argv[optind + tnum];

               /* The pthread_create() call stores the thread ID into
                  corresponding element of tinfo[] */

               s = pthread_create(&tinfo[tnum].thread_id, &attr,
                                  &thread_start, &tinfo[tnum]);
               if (s != 0)
                   handle_error_en(s, "pthread_create");
           }

           /* Destroy the thread attributes object, since it is no
              longer needed */

           s = pthread_attr_destroy(&attr);
           if (s != 0)
               handle_error_en(s, "pthread_attr_destroy");

           /* Now join with each thread, and display its returned value */

           for (tnum = 0; tnum < num_threads; tnum++) {
               s = pthread_join(tinfo[tnum].thread_id, &res);
               if (s != 0)
                   handle_error_en(s, "pthread_join");

               printf("Joined with thread %d; returned value was %s\n",
                       tinfo[tnum].thread_num, (char *) res);
               free(res);      /* Free memory allocated by thread */
           }

           free(tinfo);
           exit(EXIT_SUCCESS);
       }

BUGS
       In the obsolete LinuxThreads implementation, each of the threads in a process has a different process ID.  This is in
       violation  of  the  POSIX threads specification, and is the source of many other nonconformances to the standard; see
       pthreads(7).

SEE ALSO
       getrlimit(2),  pthread_attr_init(3),   pthread_cancel(3),   pthread_detach(3),   pthread_equal(3),   pthread_exit(3),
       pthread_getattr_np(3), pthread_join(3), pthread_self(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-11                                        PTHREAD_CREATE(3)
************************************************************************************************************
PTHREAD_DETACH(3)                                 Linux Programmer's Manual                                PTHREAD_DETACH(3)



NAME
       pthread_detach - detach a thread

SYNOPSIS
       #include <pthread.h>

       int pthread_detach(pthread_t thread);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_detach() function marks the thread identified by thread as detached.  When a detached thread terminates,
       its resources are automatically released back to the system without the need for another thread to join with the ter‐
       minated thread.

       Attempting to detach an already detached thread results in unspecified behavior.

RETURN VALUE
       On success, pthread_detach() returns 0; on error, it returns an error number.

ERRORS
       EINVAL thread is not a joinable thread.

       ESRCH  No thread with the ID thread could be found.

CONFORMING TO
       POSIX.1-2001.

NOTES
       Once a thread has been detached, it can't be joined with pthread_join(3) or be made joinable again.

       A new thread can be created in a detached state using pthread_attr_setdetachstate(3) to set the detached attribute of
       the attr argument of pthread_create(3).

       The detached attribute merely determines the behavior of the system when the thread terminates; it does  not  prevent
       the  thread  from  being  terminated  if  the  process  terminates using exit(3) (or equivalently, if the main thread
       returns).

       Either pthread_join(3) or pthread_detach() should be called for each thread that an application creates, so that sys‐
       tem resources for the thread can be released.  (But note that the resources of all threads are freed when the process
       terminates.)

EXAMPLE
       The following statement detaches the calling thread:

           pthread_detach(pthread_self());

SEE ALSO
       pthread_attr_setdetachstate(3), pthread_cancel(3), pthread_create(3), pthread_exit(3), pthread_join(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-27                                        PTHREAD_DETACH(3)
************************************************************************************************************
PTHREAD_EQUAL(3)                                  Linux Programmer's Manual                                 PTHREAD_EQUAL(3)



NAME
       pthread_equal - compare thread IDs

SYNOPSIS
       #include <pthread.h>

       int pthread_equal(pthread_t t1, pthread_t t2);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_equal() function compares two thread identifiers.

RETURN VALUE
       If the two thread IDs are equal, pthread_equal() returns a nonzero value; otherwise, it returns 0.

ERRORS
       This function always succeeds.

CONFORMING TO
       POSIX.1-2001.

NOTES
       The  pthread_equal()  function  is necessary because thread IDs should be considered opaque: there is no portable way
       for applications to directly compare two pthread_t values.

SEE ALSO
       pthread_create(3), pthread_self(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2009-03-30                                         PTHREAD_EQUAL(3)
************************************************************************************************************
PTHREAD_EXIT(3)                                   Linux Programmer's Manual                                  PTHREAD_EXIT(3)



NAME
       pthread_exit - terminate calling thread

SYNOPSIS
       #include <pthread.h>

       void pthread_exit(void *retval);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_exit() function terminates the calling thread and returns a value via retval that (if the thread is join‐
       able) is available to another thread in the same process that calls pthread_join(3).

       Any clean-up handlers established by pthread_cleanup_push(3) that have not  yet  been  popped,  are  popped  (in  the
       reverse  of  the  order  in  which they were pushed) and executed.  If the thread has any thread-specific data, then,
       after the clean-up handlers have been executed, the corresponding destructor functions are called, in an  unspecified
       order.

       When a thread terminates, process-shared resources (e.g., mutexes, condition variables, semaphores, and file descrip‐
       tors) are not released, and functions registered using atexit(3) are not called.

       After the last thread in a process terminates, the process terminates as by calling exit(3) with an  exit  status  of
       zero; thus, process-shared resources are released and functions registered using atexit(3) are called.

RETURN VALUE
       This function does not return to the caller.

ERRORS
       This function always succeeds.

CONFORMING TO
       POSIX.1-2001.

NOTES
       Performing  a  return from the start function of any thread other than the main thread results in an implicit call to
       pthread_exit(), using the function's return value as the thread's exit status.

       To allow other threads to continue execution, the main thread should terminate by calling pthread_exit() rather  than
       exit(3).

       The  value pointed to by retval should not be located on the calling thread's stack, since the contents of that stack
       are undefined after the thread terminates.

BUGS
       Currently, there are limitations in the kernel implementation logic for wait(2)ing on a stopped thread group  with  a
       dead  thread  group  leader.   This  can manifest in problems such as a locked terminal if a stop signal is sent to a
       foreground process whose thread group leader has already called pthread_exit(3).

SEE ALSO
       pthread_create(3), pthread_join(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2009-03-30                                          PTHREAD_EXIT(3)
************************************************************************************************************
PTHREAD_SETAFFINITY_NP(3)                         Linux Programmer's Manual                        PTHREAD_SETAFFINITY_NP(3)



NAME
       pthread_setaffinity_np, pthread_getaffinity_np - set/get CPU affinity of a thread

SYNOPSIS
       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <pthread.h>

       int pthread_setaffinity_np(pthread_t thread, size_t cpusetsize,
                                  const cpu_set_t *cpuset);
       int pthread_getaffinity_np(pthread_t thread, size_t cpusetsize,
                                  cpu_set_t *cpuset);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_setaffinity_np()  function  sets the CPU affinity mask of the thread thread to the CPU set pointed to by
       cpuset.  If the call is successful, and the thread is not currently running on one of the CPUs in cpuset, then it  is
       migrated to one of those CPUs.

       The  pthread_getaffinity_np() function returns the CPU affinity mask of the thread thread in the buffer pointed to by
       cpuset.

       For more details on CPU affinity masks, see sched_setaffinity(2).  For a description of a set of macros that  can  be
       used to manipulate and inspect CPU sets, see CPU_SET(3).

       The  argument cpusetsize is the length (in bytes) of the buffer pointed to by cpuset.  Typically, this argument would
       be specified as sizeof(cpu_set_t).  (It may be some other value, if using the  macros  described  in  CPU_SET(3)  for
       dynamically allocating a CPU set.)

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       EFAULT A supplied memory address was invalid.

       EINVAL (pthread_setaffinity_np())  The affinity bit mask mask contains no processors that are currently physically on
              the system and permitted to the thread according to any restrictions that may be imposed by the "cpuset" mech‐
              anism described in cpuset(7).

       EINVAL (pthread_setaffinity_np()) cpuset specified a CPU that was outside the set supported by the kernel.  (The ker‐
              nel configuration option CONFIG_NR_CPUS defines the range of the set supported by the kernel data type used to
              represent CPU sets.)

       EINVAL (pthread_getaffinity_np()) cpusetsize is smaller than the size of the affinity mask used by the kernel.

       ESRCH  No thread with the ID thread could be found.

VERSIONS
       These functions are provided by glibc since version 2.3.4.

CONFORMING TO
       These functions are nonstandard GNU extensions; hence the suffix "_np" (nonportable) in the names.

NOTES
       After  a  call to pthread_setaffinity_np(), the set of CPUs on which the thread will actually run is the intersection
       of the set specified in the cpuset argument and the set of CPUs actually present on the system.  The system may  fur‐
       ther  restrict  the  set  of  CPUs on which the thread runs if the "cpuset" mechanism described in cpuset(7) is being
       used.  These restrictions on the actual set of CPUs on which the thread will run are silently imposed by the kernel.

       These functions are implemented on top of the sched_setaffinity(2) and sched_getaffinity(2) system calls.

       In glibc 2.3.3 only, versions of these functions were provided that did not have a cpusetsize argument.  Instead  the
       CPU set size given to the underlying system calls was always sizeof(cpu_set_t).

       A new thread created by pthread_create() inherits a copy of its creator's CPU affinity mask.

EXAMPLE
       In  the following program, the main thread uses pthread_setaffinity_np() to set its CPU affinity mask to include CPUs
       0 to 7 (which may not all be available on the system), and then calls pthread_getaffinity_np() to check the resulting
       CPU affinity mask of the thread.

       #define _GNU_SOURCE
       #include <pthread.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <errno.h>

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       int
       main(int argc, char *argv[])
       {
           int s, j;
           cpu_set_t cpuset;
           pthread_t thread;

           thread = pthread_self();

           /* Set affinity mask to include CPUs 0 to 7 */

           CPU_ZERO(&cpuset);
           for (j = 0; j < 8; j++)
               CPU_SET(j, &cpuset);

           s = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
           if (s != 0)
               handle_error_en(s, "pthread_setaffinity_np");

           /* Check the actual affinity mask assigned to the thread */

           s = pthread_getaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
           if (s != 0)
               handle_error_en(s, "pthread_getaffinity_np");

           printf("Set returned by pthread_getaffinity_np() contained:\n");
           for (j = 0; j < CPU_SETSIZE; j++)
               if (CPU_ISSET(j, &cpuset))
                   printf("    CPU %d\n", j);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       sched_getcpu(3),   sched_setaffinity(2),   sched_setscheduler(2),   pthread_attr_setaffinity_np(3),  pthread_self(3),
       cpuset(7), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-09-10                                PTHREAD_SETAFFINITY_NP(3)
************************************************************************************************************
PTHREAD_GETATTR_NP(3)                             Linux Programmer's Manual                            PTHREAD_GETATTR_NP(3)



NAME
       pthread_getattr_np - get attributes of created thread

SYNOPSIS
       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <pthread.h>

       int pthread_getattr_np(pthread_t thread, pthread_attr_t *attr);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_getattr_np()  function  initializes the thread attributes object referred to by attr so that it contains
       actual attribute values describing the running thread thread.

       The returned attribute values may differ from the corresponding attribute values passed in the attr object  that  was
       used to create the thread using pthread_create(3).  In particular, the following attributes may differ:

       * the detach state, since a joinable thread may have detached itself after creation;

       * the stack size, which the implementation may align to a suitable boundary.

       * and  the  guard  size,  which the implementation may round upwards to a multiple of the page size, or ignore (i.e.,
         treat as 0), if the application is allocating its own stack.

       Furthermore, if the stack address attribute was not set in the thread attributes object used to  create  the  thread,
       then  the returned thread attributes object will report the actual stack address that the implementation selected for
       the thread.

       When the thread attributes object returned by pthread_getattr_np() is no longer  required,  it  should  be  destroyed
       using pthread_attr_destroy(3).

RETURN VALUE
       On success, this function returns 0; on error, it returns a nonzero error number.

ERRORS
       ENOMEM Insufficient memory.

       In  addition,  if thread refers to the main thread, then pthread_getattr_np() can fail because of errors from various
       underlying calls: fopen(3), if /proc/self/maps can't be opened; and getrlimit(2), if the RLIMIT_STACK resource  limit
       is not supported.

VERSIONS
       This function is available in glibc since version 2.2.3.

CONFORMING TO
       This function is a nonstandard GNU extension; hence the suffix "_np" (nonportable) in the name.

EXAMPLE
       The  program  below  demonstrates  the  use  of  pthread_getattr_np().   The  program creates a thread that then uses
       pthread_getattr_np() to retrieve and display its guard size, stack address, and stack size attributes.   Command-line
       arguments  can  be used to set these attributes to values other than the default when creating the thread.  The shell
       sessions below demonstrate the use of the program.

       In the first run, on an x86-32 system, a thread is created using default attributes:

           $ ulimit -s      # No stack limit ==> default stack size is 2MB
           unlimited
           $ ./a.out
           Attributes of created thread:
                   Guard size          = 4096 bytes
                   Stack address       = 0x40196000 (EOS = 0x40397000)
                   Stack size          = 0x201000 (2101248) bytes

       In the following run, we see that if a guard size is specified, it is rounded up to the next multiple of  the  system
       page size (4096 bytes on x86-32):

           $ ./a.out -g 4097
           Thread attributes object after initializations:
                   Guard size          = 4097 bytes
                   Stack address       = (nil)
                   Stack size          = 0x0 (0) bytes

           Attributes of created thread:
                   Guard size          = 8192 bytes
                   Stack address       = 0x40196000 (EOS = 0x40397000)
                   Stack size          = 0x201000 (2101248) bytes

       In  the  last  run, the program manually allocates a stack for the thread.  In this case, the guard size attribute is
       ignored.

           $ ./a.out -g 4096 -s 0x8000 -a
           Allocated thread stack at 0x804d000

           Thread attributes object after initializations:
                   Guard size          = 4096 bytes
                   Stack address       = 0x804d000 (EOS = 0x8055000)
                   Stack size          = 0x8000 (32768) bytes

           Attributes of created thread:
                   Guard size          = 0 bytes
                   Stack address       = 0x804d000 (EOS = 0x8055000)
                   Stack size          = 0x8000 (32768) bytes

   Program source

       #define _GNU_SOURCE     /* To get pthread_getattr_np() declaration */
       #include <pthread.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <errno.h>

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       static void
       display_stack_related_attributes(pthread_attr_t *attr, char *prefix)
       {
           int s;
           size_t stack_size, guard_size;
           void *stack_addr;

           s = pthread_attr_getguardsize(attr, &guard_size);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getguardsize");
           printf("%sGuard size          = %d bytes\n", prefix, guard_size);

           s = pthread_attr_getstack(attr, &stack_addr, &stack_size);
           if (s != 0)
               handle_error_en(s, "pthread_attr_getstack");
           printf("%sStack address       = %p", prefix, stack_addr);
           if (stack_size > 0)
               printf(" (EOS = %p)", (char *) stack_addr + stack_size);
           printf("\n");
           printf("%sStack size          = 0x%x (%d) bytes\n",
                   prefix, stack_size, stack_size);
       }

       static void
       display_thread_attributes(pthread_t thread, char *prefix)
       {
           int s;
           pthread_attr_t attr;

           s = pthread_getattr_np(thread, &attr);
           if (s != 0)
               handle_error_en(s, "pthread_getattr_np");

           display_stack_related_attributes(&attr, prefix);

           s = pthread_attr_destroy(&attr);
           if (s != 0)
               handle_error_en(s, "pthread_attr_destroy");
       }

       static void *           /* Start function for thread we create */
       thread_start(void *arg)
       {
           printf("Attributes of created thread:\n");
           display_thread_attributes(pthread_self(), "\t");

           exit(EXIT_SUCCESS);         /* Terminate all threads */
       }

       static void
       usage(char *pname, char *msg)
       {
           if (msg != NULL)
               fputs(msg, stderr);
           fprintf(stderr, "Usage: %s [-s stack-size [-a]]"
                   " [-g guard-size]\n", pname);
           fprintf(stderr, "\t\t-a means program should allocate stack\n");
           exit(EXIT_FAILURE);
       }

       static pthread_attr_t *   /* Get thread attributes from command line */
       get_thread_attributes_from_cl(int argc, char *argv[],
                                     pthread_attr_t *attrp)
       {
           int s, opt, allocate_stack;
           long stack_size, guard_size;
                   void *stack_addr;
           pthread_attr_t *ret_attrp = NULL;   /* Set to attrp if we initialize
                                                  a thread attributes object */
           allocate_stack = 0;
           stack_size = -1;
           guard_size = -1;

           while ((opt = getopt(argc, argv, "ag:s:")) != -1) {
               switch (opt) {
               case 'a':   allocate_stack = 1;                     break;
               case 'g':   guard_size = strtoul(optarg, NULL, 0);  break;
               case 's':   stack_size = strtoul(optarg, NULL, 0);  break;
               default:    usage(argv[0], NULL);
               }
           }

           if (allocate_stack && stack_size == -1)
               usage(argv[0], "Specifying -a without -s makes no sense\n");

           if (argc > optind)
               usage(argv[0], "Extraneous command-line arguments\n");

           if (stack_size >= 0 || guard_size > 0) {
               ret_attrp = attrp;

               s = pthread_attr_init(attrp);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_init");
           }

           if (stack_size >= 0) {
               if (!allocate_stack) {
                   s = pthread_attr_setstacksize(attrp, stack_size);
                   if (s != 0)
                       handle_error_en(s, "pthread_attr_setstacksize");
               } else {
                   s = posix_memalign(&stack_addr, sysconf(_SC_PAGESIZE),
                                      stack_size);
                   if (s != 0)
                       handle_error_en(s, "posix_memalign");
                   printf("Allocated thread stack at %p\n\n", stack_addr);

                   s = pthread_attr_setstack(attrp, stack_addr, stack_size);
                   if (s != 0)
                       handle_error_en(s, "pthread_attr_setstacksize");
               }
           }

           if (guard_size >= 0) {
               s = pthread_attr_setguardsize(attrp, guard_size);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setstacksize");
           }

           return ret_attrp;
       }

       int
       main(int argc, char *argv[])
       {
           int s;
           pthread_t thr;
           pthread_attr_t attr;
           pthread_attr_t *attrp = NULL;    /* Set to &attr if we initialize
                                               a thread attributes object */

           attrp = get_thread_attributes_from_cl(argc, argv, &attr);

           if (attrp != NULL) {
               printf("Thread attributes object after initializations:\n");
               display_stack_related_attributes(attrp, "\t");
               printf("\n");
           }

           s = pthread_create(&thr, attrp, &thread_start, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           if (attrp != NULL) {
               s = pthread_attr_destroy(attrp);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_destroy");
           }

           pause();    /* Terminates when other thread calls exit() */
       }

SEE ALSO
       pthread_attr_getaffinity_np(3), pthread_attr_getdetachstate(3), pthread_attr_getguardsize(3),  pthread_attr_getinher‐
       itsched(3),       pthread_attr_getschedparam(3),       pthread_attr_getschedpolicy(3),      pthread_attr_getscope(3),
       pthread_attr_getstack(3),    pthread_attr_getstackaddr(3),    pthread_attr_getstacksize(3),     pthread_attr_init(3),
       pthread_create(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-09-10                                    PTHREAD_GETATTR_NP(3)
************************************************************************************************************
PTHREAD_SETCONCURRENCY(3)                         Linux Programmer's Manual                        PTHREAD_SETCONCURRENCY(3)



NAME
       pthread_setconcurrency, pthread_getconcurrency - set/get the concurrency level

SYNOPSIS
       #include <pthread.h>

       int pthread_setconcurrency(int new_level);
       int pthread_getconcurrency(void);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_setconcurrency()  function  informs  the  implementation of the application's desired concurrency level,
       specified in new_level.  The implementation only takes this as a hint: POSIX.1 does not specify the level of  concur‐
       rency that should be provided as a result of calling pthread_setconcurrency().

       Specifying new_level as 0 instructs the implementation to manage the concurrency level as it deems appropriate.

       pthread_getconcurrency() returns the current value of the concurrency level for this process.

RETURN VALUE
       On success, pthread_setconcurrency() returns 0; on error, it returns a nonzero error number.

       pthread_getconcurrency()  always  succeeds, returning the concurrency level set by a previous call to pthread_setcon‐
       currency(), or 0, if pthread_setconcurrency() has not previously been called.

ERRORS
       pthread_setconcurrency() can fail with the following error:

       EINVAL new_level is negative.

       POSIX.1-2001 also documents an EAGAIN error ("the value specified by new_level would cause a system  resource  to  be
       exceeded").

VERSIONS
       These functions are available in glibc since version 2.1.

CONFORMING TO
       POSIX.1-2001.

NOTES
       The default concurrency level is 0.

       Concurrency levels are only meaningful for M:N threading implementations, where at any moment a subset of a process's
       set of user-level threads may be bound to a smaller number of kernel-scheduling entities.   Setting  the  concurrency
       level  allows the application to give the system a hint as to the number of kernel-scheduling entities that should be
       provided for efficient execution of the application.

       Both LinuxThreads and NPTL are 1:1 threading implementations, so setting the concurrency level has  no  meaning.   In
       other  words,  on Linux these functions merely exist for compatibility with other systems, and they have no effect on
       the execution of a program.

SEE ALSO
       pthread_attr_setscope(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2009-04-10                                PTHREAD_SETCONCURRENCY(3)
************************************************************************************************************
PTHREAD_GETCPUCLOCKID(3)                          Linux Programmer's Manual                         PTHREAD_GETCPUCLOCKID(3)



NAME
       pthread_getcpuclockid - retrieve ID of a thread's CPU time clock

SYNOPSIS
       #include <pthread.h>
       #include <time.h>

       int pthread_getcpuclockid(pthread_t thread, clockid_t *clock_id);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_getcpuclockid() function returns the clock ID for the CPU time clock of the thread thread.

RETURN VALUE
       On success, this function returns 0; on error, it returns a nonzero error number.

ERRORS
       ENOENT Per-thread CPU time clocks are not supported by the system.

       ESRCH  No thread with the ID thread could be found.

VERSIONS
       This function is available in glibc since version 2.2.

CONFORMING TO
       POSIX.1-2001.

NOTES
       When  thread  refers to the calling thread, this function returns an identifier that refers to the same clock manipu‐
       lated by clock_gettime(2) and clock_settime(2) when given the clock ID CLOCK_THREAD_CPUTIME_ID.

EXAMPLE
       The program below creates a thread and then uses clock_gettime(2) to retrieve the total process  CPU  time,  and  the
       per-thread CPU time consumed by the two threads.  The following shell session shows an example run:
           $ ./a.out
           Main thread sleeping
           Subthread starting infinite loop
           Main thread consuming some CPU time...
           Process total CPU time:    1.368
           Main thread CPU time:      0.376
           Subthread CPU time:        0.992

   Program source

       /* Link with "-lrt" */

       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <pthread.h>
       #include <string.h>
       #include <errno.h>

       #define handle_error(msg) \
               do { perror(msg); exit(EXIT_FAILURE); } while (0)

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       static void *
       thread_start(void *arg)
       {
           printf("Subthread starting infinite loop\n");
           for (;;)
               continue;
       }

       static void
       pclock(char *msg, clockid_t cid)
       {
           struct timespec ts;

           printf("%s", msg);
           if (clock_gettime(cid, &ts) == -1)
               handle_error("clock_gettime");
           printf("%4ld.%03ld\n", ts.tv_sec, ts.tv_nsec / 1000000);
       }

       int
       main(int argc, char *argv[])
       {
           pthread_t thread;
           clockid_t cid;
           int j, s;

           s = pthread_create(&thread, NULL, thread_start, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           printf("Main thread sleeping\n");
           sleep(1);

           printf("Main thread consuming some CPU time...\n");
           for (j = 0; j < 2000000; j++)
               getppid();

           pclock("Process total CPU time: ", CLOCK_PROCESS_CPUTIME_ID);

           s = pthread_getcpuclockid(pthread_self(), &cid);
           if (s != 0)
               handle_error_en(s, "pthread_getcpuclockid");
           pclock("Main thread CPU time:   ", cid);

           /* The preceding 4 lines of code could have been replaced by:
              pclock("Main thread CPU time:   ", CLOCK_THREAD_CPUTIME_ID); */

           s = pthread_getcpuclockid(thread, &cid);
           if (s != 0)
               handle_error_en(s, "pthread_getcpuclockid");
           pclock("Subthread CPU time: 1    ", cid);

           exit(EXIT_SUCCESS);         /* Terminates both threads */
       }

SEE ALSO
       clock_gettime(2), clock_settime(2), timer_create(2), clock_getcpuclockid(3), pthread_self(3), pthreads(7), time(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2009-02-08                                 PTHREAD_GETCPUCLOCKID(3)
************************************************************************************************************
PTHREAD_SETSCHEDPARAM(3)                          Linux Programmer's Manual                         PTHREAD_SETSCHEDPARAM(3)



NAME
       pthread_setschedparam, pthread_getschedparam - set/get scheduling policy and parameters of a thread

SYNOPSIS
       #include <pthread.h>

       pthread_setschedparam(pthread_t thread, int policy,
                             const struct sched_param *param);
       pthread_getschedparam(pthread_t thread, int *policy,
                             struct sched_param *param);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_setschedparam() function sets the scheduling policy and parameters of the thread thread.

       policy  specifies  the  new  scheduling policy for thread.  The supported values for policy, and their semantics, are
       described in sched_setscheduler(2).

       The structure pointed to by param specifies the new scheduling parameters  for  thread.   Scheduling  parameters  are
       maintained in the following structure:

           struct sched_param {
               int sched_priority;     /* Scheduling priority */
           };

       As  can be seen, only one scheduling parameter is supported.  For details of the permitted ranges for scheduling pri‐
       orities in each scheduling policy, see sched_setscheduler(2).

       The pthread_getschedparam() function returns the scheduling policy and parameters of the thread thread, in  the  buf‐
       fers  pointed  to  by  policy  and  param,  respectively.  The returned priority value is that set by the most recent
       pthread_setschedparam(), pthread_setschedprio(3), or pthread_create(3) call that affected thread.  The returned  pri‐
       ority  does not reflect any temporary priority adjustments as a result of calls to any priority inheritance or prior‐
       ity ceiling functions (see, for example, pthread_mutexattr_setprioceiling(3) and pthread_mutexattr_setprotocol(3)).

RETURN VALUE
       On success, these functions return 0; on error, they return  a  nonzero  error  number.   If  pthread_setschedparam()
       fails, the scheduling policy and parameters of thread are not changed.

ERRORS
       Both of these functions can fail with the following error:

       ESRCH  No thread with the ID thread could be found.

       pthread_setschedparam() may additionally fail with the following errors:

       EINVAL policy is not a recognized policy, or param does not make sense for the policy.

       EPERM  The caller does not have appropriate privileges to set the specified scheduling policy and parameters.

       POSIX.1-2001  also  documents  an  ENOTSUP ("attempt was made to set the policy or scheduling parameters to an unsup‐
       ported value") error for pthread_setschedparam().

CONFORMING TO
       POSIX.1-2001.

NOTES
       For a description of the permissions required to, and the effect of, changing a thread's scheduling policy and prior‐
       ity, and details of the permitted ranges for priorities in each scheduling policy, see sched_setscheduler(2).

EXAMPLE
       The  program below demonstrates the use of pthread_setschedparam() and pthread_getschedparam(), as well as the use of
       a number of other scheduling-related pthreads functions.

       In the following run, the main thread sets its scheduling policy to SCHED_FIFO with a priority of 10, and initializes
       a  thread attributes object with a scheduling policy attribute of SCHED_RR and a scheduling priority attribute of 20.
       The program then  sets  (using  pthread_attr_setinheritsched(3))  the  inherit  scheduler  attribute  of  the  thread
       attributes  object  to  PTHREAD_EXPLICIT_SCHED, meaning that threads created using this attributes object should take
       their scheduling attributes from the thread attributes object.  The program then creates a thread  using  the  thread
       attributes object, and that thread displays its scheduling policy and priority.

           $ su      # Need privilege to set real-time scheduling policies
           Password:
           # ./a.out -mf10 -ar20 -i e
           Scheduler settings of main thread
               policy=SCHED_FIFO, priority=10

           Scheduler settings in 'attr'
               policy=SCHED_RR, priority=20
               inheritsched is EXPLICIT

           Scheduler attributes of new thread
               policy=SCHED_RR, priority=20

       In  the above output, one can see that the scheduling policy and priority were taken from the values specified in the
       thread attributes object.

       The  next  run  is  the  same  as  the  previous,  except  that  the  inherit   scheduler   attribute   is   set   to
       PTHREAD_INHERIT_SCHED,  meaning  that threads created using the thread attributes object should ignore the scheduling
       attributes specified in the attributes object and instead take their scheduling attributes from the creating thread.

           # ./a.out -mf10 -ar20 -i i
           Scheduler settings of main thread
               policy=SCHED_FIFO, priority=10

           Scheduler settings in 'attr'
               policy=SCHED_RR, priority=20
               inheritsched is INHERIT

           Scheduler attributes of new thread
               policy=SCHED_FIFO, priority=10

       In the above output, one can see that the scheduling policy and priority were taken from the creating thread,  rather
       than the thread attributes object.

       Note  that if we had omitted the -i i option, the output would have been the same, since PTHREAD_INHERIT_SCHED is the
       default for the inherit scheduler attribute.

   Program source

       /* pthreads_sched_test.c */

       #include <pthread.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <errno.h>

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       static void
       usage(char *prog_name, char *msg)
       {
           if (msg != NULL)
               fputs(msg, stderr);

           fprintf(stderr, "Usage: %s [options]\n", prog_name);
           fprintf(stderr, "Options are:\n");
       #define fpe(msg) fprintf(stderr, "\t%s", msg);          /* Shorter */
           fpe("-a<policy><prio> Set scheduling policy and priority in\n");
           fpe("                 thread attributes object\n");
           fpe("                 <policy> can be\n");
           fpe("                     f  SCHED_FIFO\n");
           fpe("                     r  SCHED_RR\n");
           fpe("                     o  SCHED_OTHER\n");
           fpe("-A               Use default thread attributes object\n");
           fpe("-i {e|s}         Set inherit scheduler attribute to\n");
           fpe("                 'explicit' or 'inherit'\n");
           fpe("-m<policy><prio> Set scheduling policy and priority on\n");
           fpe("                 main thread before pthread_create() call\n");
           exit(EXIT_FAILURE);
       } /* usage */

       static int
       get_policy(char p, int *policy)
       {
           switch (p) {
           case 'f': *policy = SCHED_FIFO;     return 1;
           case 'r': *policy = SCHED_RR;       return 1;
           case 'o': *policy = SCHED_OTHER;    return 1;
           default:  return 0;
           }
       } /* get_policy */

       static void
       display_sched_attr(int policy, struct sched_param *param)
       {
           printf("    policy=%s, priority=%d\n",
                   (policy == SCHED_FIFO)  ? "SCHED_FIFO" :
                   (policy == SCHED_RR)    ? "SCHED_RR" :
                   (policy == SCHED_OTHER) ? "SCHED_OTHER" :
                   "???",
                   param->sched_priority);
       } /* display_sched_attr */

       static void
       display_thread_sched_attr(char *msg)
       {
           int policy, s;
           struct sched_param param;

           s = pthread_getschedparam(pthread_self(), &policy, &param);
           if (s != 0)
               handle_error_en(s, "pthread_getschedparam");

           printf("%s\n", msg);
           display_sched_attr(policy, &param);
       } /* display_thread_sched_attr */

       static void *
       thread_start(void *arg)
       {
           display_thread_sched_attr("Scheduler attributes of new thread");

           return NULL;
       } /* thread_start */

       int
       main(int argc, char *argv[])
       {
           int s, opt, inheritsched, use_null_attrib, policy;
           pthread_t thread;
           pthread_attr_t attr;
           pthread_attr_t *attrp;
           char *attr_sched_str, *main_sched_str, *inheritsched_str;
           struct sched_param param;

           /* Process command-line options */

           use_null_attrib = 0;
           attr_sched_str = NULL;
           main_sched_str = NULL;
           inheritsched_str = NULL;

           while ((opt = getopt(argc, argv, "a:Ai:m:")) != -1) {
               switch (opt) {
               case 'a': attr_sched_str = optarg;      break;
               case 'A': use_null_attrib = 1;          break;
               case 'i': inheritsched_str = optarg;    break;
               case 'm': main_sched_str = optarg;      break;
               default:  usage(argv[0], "Unrecognized option\n");
               }
           }

           if (use_null_attrib &&
                   (inheritsched_str != NULL || attr_sched_str != NULL))
               usage(argv[0], "Can't specify -A with -i or -a\n");

           /* Optionally set scheduling attributes of main thread,
              and display the attributes */

           if (main_sched_str != NULL) {
               if (!get_policy(main_sched_str[0], &policy))
                   usage(argv[0], "Bad policy for main thread (-s)\n");
               param.sched_priority = strtol(&main_sched_str[1], NULL, 0);

               s = pthread_setschedparam(pthread_self(), policy, &param);
               if (s != 0)
                   handle_error_en(s, "pthread_setschedparam");
           }

           display_thread_sched_attr("Scheduler settings of main thread");
           printf("\n");

           /* Initialize thread attributes object according to options */

           attrp = NULL;

           if (!use_null_attrib) {
               s = pthread_attr_init(&attr);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_init");
               attrp = &attr;
           }

           if (inheritsched_str != NULL) {
               if (inheritsched_str[0] == 'e')
                   inheritsched = PTHREAD_EXPLICIT_SCHED;
               else if (inheritsched_str[0] == 'i')
                   inheritsched = PTHREAD_INHERIT_SCHED;
               else
                   usage(argv[0], "Value for -i must be 'e' or 'i'\n");

               s = pthread_attr_setinheritsched(&attr, inheritsched);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setinheritsched");
           }

           if (attr_sched_str != NULL) {
               if (!get_policy(attr_sched_str[0], &policy))
                   usage(argv[0],
                           "Bad policy for 'attr' (-a)\n");
               param.sched_priority = strtol(&attr_sched_str[1], NULL, 0);

               s = pthread_attr_setschedpolicy(&attr, policy);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setschedpolicy");
               s = pthread_attr_setschedparam(&attr, &param);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setschedparam");
           }

           /* If we initialized a thread attributes object, display
              the scheduling attributes that were set in the object */

           if (attrp != NULL) {
               s = pthread_attr_getschedparam(&attr, &param);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_getschedparam");
               s = pthread_attr_getschedpolicy(&attr, &policy);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_getschedpolicy");

               printf("Scheduler settings in 'attr'\n");
               display_sched_attr(policy, &param);

               s = pthread_attr_getinheritsched(&attr, &inheritsched);
               printf("    inheritsched is %s\n",
                       (inheritsched == PTHREAD_INHERIT_SCHED)  ? "INHERIT" :
                       (inheritsched == PTHREAD_EXPLICIT_SCHED) ? "EXPLICIT" :
                       "???");
               printf("\n");
           }

           /* Create a thread that will display its scheduling attributes */

           s = pthread_create(&thread, attrp, &thread_start, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           /* Destroy unneeded thread attributes object */

           s = pthread_attr_destroy(&attr);
           if (s != 0)
               handle_error_en(s, "pthread_attr_destroy");

           s = pthread_join(thread, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_join");

           exit(EXIT_SUCCESS);
       } /* main */

SEE ALSO
       getrlimit(2),   sched_get_priority_min(2),   sched_setscheduler(2),   pthread_attr_init(3),    pthread_attr_setinher‐
       itsched(3),   pthread_attr_setschedparam(3),  pthread_attr_setschedpolicy(3),  pthread_setschedprio(3),  pthread_cre‐
       ate(3), pthread_self(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-17                                 PTHREAD_SETSCHEDPARAM(3)
************************************************************************************************************
PTHREAD_JOIN(3)                                   Linux Programmer's Manual                                  PTHREAD_JOIN(3)



NAME
       pthread_join - join with a terminated thread

SYNOPSIS
       #include <pthread.h>

       int pthread_join(pthread_t thread, void **retval);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_join() function waits for the thread specified by thread to terminate.  If that thread has already termi‐
       nated, then pthread_join() returns immediately.  The thread specified by thread must be joinable.

       If retval is not NULL, then pthread_join() copies the exit status of the target thread (i.e., the value that the tar‐
       get  thread supplied to pthread_exit(3)) into the location pointed to by *retval.  If the target thread was canceled,
       then PTHREAD_CANCELED is placed in *retval.

       If multiple threads simultaneously try to join with the same thread, the results are undefined.  If the thread  call‐
       ing pthread_join() is canceled, then the target thread will remain joinable (i.e., it will not be detached).

RETURN VALUE
       On success, pthread_join() returns 0; on error, it returns an error number.

ERRORS
       EDEADLK
              A  deadlock  was  detected  (e.g., two threads tried to join with each other); or thread specifies the calling
              thread.

       EINVAL thread is not a joinable thread.

       EINVAL Another thread is already waiting to join with this thread.

       ESRCH  No thread with the ID thread could be found.

CONFORMING TO
       POSIX.1-2001.

NOTES
       After a successful call to pthread_join(), the caller is guaranteed that the target thread has terminated.

       Joining with a thread that has previously been joined results in undefined behavior.

       Failure to join with a thread that is joinable (i.e., one that is not detached), produces a "zombie  thread".   Avoid
       doing this, since each zombie thread consumes some system resources, and when enough zombie threads have accumulated,
       it will no longer be possible to create new threads (or processes).

       There is no pthreads analog of waitpid(-1, &status, 0), that is, "join with any terminated thread".  If  you  believe
       you need this functionality, you probably need to rethink your application design.

       All of the threads in a process are peers: any thread can join with any other thread in the process.

EXAMPLE
       See pthread_create(3).

SEE ALSO
       pthread_cancel(3), pthread_create(3), pthread_detach(3), pthread_exit(3), pthread_tryjoin_np(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-27                                          PTHREAD_JOIN(3)
************************************************************************************************************
PTHREAD_KILL(3)                                   Linux Programmer's Manual                                  PTHREAD_KILL(3)



NAME
       pthread_kill - send a signal to a thread

SYNOPSIS
       #include <signal.h>

       int pthread_kill(pthread_t thread, int sig);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_kill()  function  sends the signal sig to thread, another thread in the same process as the caller.  The
       signal is asynchronously directed to thread.

       If sig is 0, then no signal is sent, but error checking is still performed; this can be used to check for  the  exis‐
       tence of a thread ID.

RETURN VALUE
       On success, pthread_kill() returns 0; on error, it returns an error number, and no signal is sent.

ERRORS
       ESRCH  No thread with the ID thread could be found.

       EINVAL An invalid signal was specified.

CONFORMING TO
       POSIX.1-2001.

NOTES
       Signal  dispositions  are  process-wide:  if a signal handler is installed, the handler will be invoked in the thread
       thread, but if the disposition of the signal is "stop", "continue", or "terminate", this action will affect the whole
       process.

SEE ALSO
       kill(2) sigaction(2), sigpending(2), pthread_self(3), pthread_sigmask(3), raise(3), pthreads(7), signal(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2009-01-28                                          PTHREAD_KILL(3)
************************************************************************************************************
PTHREAD_KILL_OTHER_THREADS_NP(3)                  Linux Programmer's Manual                 PTHREAD_KILL_OTHER_THREADS_NP(3)



NAME
       pthread_kill_other_threads_np - terminate all other threads in process

SYNOPSIS
       #include <pthread.h>

       void pthread_kill_other_threads_np(void);

DESCRIPTION
       pthread_kill_other_threads_np() only has an effect in the LinuxThreads threading implementation.  On that implementa‐
       tion, calling this function causes the immediate termination of all threads in the application,  except  the  calling
       thread.   The  cancellation  state and cancellation type of the to-be-terminated threads are ignored, and the cleanup
       handlers are not called in those threads.

CONFORMING TO
       This function is a nonstandard GNU extension; hence the suffix "_np" (nonportable) in the name.

NOTES
       pthread_kill_other_threads_np() is intended to be called just before a thread calls execve(2) or a similar  function.
       This  function  is  designed  to  address  a limitation in the obsolete LinuxThreads implementation whereby the other
       threads of an application are not automatically terminated (as POSIX.1-2001 requires) during execve(2).

       In the NPTL threading implementation, pthread_kill_other_threads_np() exists, but does nothing.  (Nothing needs to be
       done, because the implementation does the right thing during an execve(2).)

SEE ALSO
       execve(2), pthread_setcancelstate(3), pthread_setcanceltype(3), pthread_cancel(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-09-09                         PTHREAD_KILL_OTHER_THREADS_NP(3)
************************************************************************************************************
PTHREADS(7)                                       Linux Programmer's Manual                                      PTHREADS(7)



NAME
       pthreads - POSIX threads

DESCRIPTION
       POSIX.1  specifies  a  set  of  interfaces (functions, header files) for threaded programming commonly known as POSIX
       threads, or Pthreads.  A single process can contain multiple threads, all of which are executing  the  same  program.
       These  threads  share  the  same global memory (data and heap segments), but each thread has its own stack (automatic
       variables).

       POSIX.1 also requires that threads share a range of other attributes (i.e., these attributes are process-wide  rather
       than per-thread):

       -  process ID

       -  parent process ID

       -  process group ID and session ID

       -  controlling terminal

       -  user and group IDs

       -  open file descriptors

       -  record locks (see fcntl(2))

       -  signal dispositions

       -  file mode creation mask (umask(2))

       -  current directory (chdir(2)) and root directory (chroot(2))

       -  interval timers (setitimer(2)) and POSIX timers (timer_create(2))

       -  nice value (setpriority(2))

       -  resource limits (setrlimit(2))

       -  measurements of the consumption of CPU time (times(2)) and resources (getrusage(2))

       As well as the stack, POSIX.1 specifies that various other attributes are distinct for each thread, including:

       -  thread ID (the pthread_t data type)

       -  signal mask (pthread_sigmask(3))

       -  the errno variable

       -  alternate signal stack (sigaltstack(2))

       -  real-time scheduling policy and priority (sched_setscheduler(2) and sched_setparam(2))

       The following Linux-specific features are also per-thread:

       -  capabilities (see capabilities(7))

       -  CPU affinity (sched_setaffinity(2))

   Pthreads function return values
       Most pthreads functions return 0 on success, and an error number of failure.  Note that the pthreads functions do not
       set errno.  For each of the pthreads functions that can return an error, POSIX.1-2001 specifies that the function can
       never fail with the error EINTR.

   Thread IDs
       Each  of  the threads in a process has a unique thread identifier (stored in the type pthread_t).  This identifier is
       returned to the caller of pthread_create(3), and a thread can obtain its own thread identifier using pthread_self(3).
       Thread  IDs  are  only guaranteed to be unique within a process.  A thread ID may be reused after a terminated thread
       has been joined, or a detached thread has terminated.  In all pthreads functions that accept a thread ID as an  argu‐
       ment, that ID by definition refers to a thread in the same process as the caller.

   Thread-safe functions
       A thread-safe function is one that can be safely (i.e., it will deliver the same results regardless of whether it is)
       called from multiple threads at the same time.

       POSIX.1-2001 and POSIX.1-2008 require that all functions specified in the standard shall be thread-safe,  except  for
       the following functions:

           asctime()
           basename()
           catgets()
           crypt()
           ctermid() if passed a non-NULL argument
           ctime()
           dbm_clearerr()
           dbm_close()
           dbm_delete()
           dbm_error()
           dbm_fetch()
           dbm_firstkey()
           dbm_nextkey()
           dbm_open()
           dbm_store()
           dirname()
           dlerror()
           drand48()
           ecvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           encrypt()
           endgrent()
           endpwent()
           endutxent()
           fcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           ftw()
           gcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           getc_unlocked()
           getchar_unlocked()
           getdate()
           getenv()
           getgrent()
           getgrgid()
           getgrnam()
           gethostbyaddr() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           gethostbyname() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           gethostent()
           getlogin()
           getnetbyaddr()
           getnetbyname()
           getnetent()
           getopt()
           getprotobyname()
           getprotobynumber()
           getprotoent()
           getpwent()
           getpwnam()
           getpwuid()
           getservbyname()
           getservbyport()
           getservent()
           getutxent()
           getutxid()
           getutxline()
           gmtime()
           hcreate()
           hdestroy()
           hsearch()
           inet_ntoa()
           l64a()
           lgamma()
           lgammaf()
           lgammal()
           localeconv()
           localtime()
           lrand48()
           mrand48()
           nftw()
           nl_langinfo()
           ptsname()
           putc_unlocked()
           putchar_unlocked()
           putenv()
           pututxline()
           rand()
           readdir()
           setenv()
           setgrent()
           setkey()
           setpwent()
           setutxent()
           strerror()
           strsignal() [Added in POSIX.1-2008]
           strtok()
           system() [Added in POSIX.1-2008]
           tmpnam() if passed a non-NULL argument
           ttyname()
           unsetenv()
           wcrtomb() if its final argument is NULL
           wcsrtombs() if its final argument is NULL
           wcstombs()
           wctomb()

   Cancellation Points
       POSIX.1  specifies that certain functions must, and certain other functions may, be cancellation points.  If a thread
       is cancelable, its cancelability type is deferred, and a cancellation request is pending for  the  thread,  then  the
       thread is canceled when it calls a function that is a cancellation point.

       The following functions are required to be cancellation points by POSIX.1-2001 and/or POSIX.1-2008:

           accept()
           aio_suspend()
           clock_nanosleep()
           close()
           connect()
           creat()
           fcntl() F_SETLKW
           fdatasync()
           fsync()
           getmsg()
           getpmsg()
           lockf() F_LOCK
           mq_receive()
           mq_send()
           mq_timedreceive()
           mq_timedsend()
           msgrcv()
           msgsnd()
           msync()
           nanosleep()
           open()
           openat() [Added in POSIX.1-2008]
           pause()
           poll()
           pread()
           pselect()
           pthread_cond_timedwait()
           pthread_cond_wait()
           pthread_join()
           pthread_testcancel()
           putmsg()
           putpmsg()
           pwrite()
           read()
           readv()
           recv()
           recvfrom()
           recvmsg()
           select()
           sem_timedwait()
           sem_wait()
           send()
           sendmsg()
           sendto()
           sigpause() [POSIX.1-2001 only (moves to "may" list in POSIX.1-2008)]
           sigsuspend()
           sigtimedwait()
           sigwait()
           sigwaitinfo()
           sleep()
           system()
           tcdrain()
           usleep() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           wait()
           waitid()
           waitpid()
           write()
           writev()

       The following functions may be cancellation points according to POSIX.1-2001 and/or POSIX.1-2008:

           access()
           asctime()
           asctime_r()
           catclose()
           catgets()
           catopen()
           chmod() [Added in POSIX.1-2008]
           chown() [Added in POSIX.1-2008]
           closedir()
           closelog()
           ctermid()
           ctime()
           ctime_r()
           dbm_close()
           dbm_delete()
           dbm_fetch()
           dbm_nextkey()
           dbm_open()
           dbm_store()
           dlclose()
           dlopen()
           dprintf() [Added in POSIX.1-2008]
           endgrent()
           endhostent()
           endnetent()
           endprotoent()
           endpwent()
           endservent()
           endutxent()
           faccessat() [Added in POSIX.1-2008]
           fchmod() [Added in POSIX.1-2008]
           fchmodat() [Added in POSIX.1-2008]
           fchown() [Added in POSIX.1-2008]
           fchownat() [Added in POSIX.1-2008]
           fclose()
           fcntl() (for any value of cmd argument)
           fflush()
           fgetc()
           fgetpos()
           fgets()
           fgetwc()
           fgetws()
           fmtmsg()
           fopen()
           fpathconf()
           fprintf()
           fputc()
           fputs()
           fputwc()
           fputws()
           fread()
           freopen()
           fscanf()
           fseek()
           fseeko()
           fsetpos()
           fstat()
           fstatat() [Added in POSIX.1-2008]
           ftell()
           ftello()
           ftw()
           futimens() [Added in POSIX.1-2008]
           fwprintf()
           fwrite()
           fwscanf()
           getaddrinfo()
           getc()
           getc_unlocked()
           getchar()
           getchar_unlocked()
           getcwd()
           getdate()
           getdelim() [Added in POSIX.1-2008]
           getgrent()
           getgrgid()
           getgrgid_r()
           getgrnam()
           getgrnam_r()
           gethostbyaddr() [SUSv3 only (function removed in POSIX.1-2008)]
           gethostbyname() [SUSv3 only (function removed in POSIX.1-2008)]
           gethostent()
           gethostid()
           gethostname()
           getline() [Added in POSIX.1-2008]
           getlogin()
           getlogin_r()
           getnameinfo()
           getnetbyaddr()
           getnetbyname()
           getnetent()
           getopt() (if opterr is nonzero)
           getprotobyname()
           getprotobynumber()
           getprotoent()
           getpwent()
           getpwnam()
           getpwnam_r()
           getpwuid()
           getpwuid_r()
           gets()
           getservbyname()
           getservbyport()
           getservent()
           getutxent()
           getutxid()
           getutxline()
           getwc()
           getwchar()
           getwd() [SUSv3 only (function removed in POSIX.1-2008)]
           glob()
           iconv_close()
           iconv_open()
           ioctl()
           link()
           linkat() [Added in POSIX.1-2008]
           lio_listio() [Added in POSIX.1-2008]
           localtime()
           localtime_r()
           lockf() [Added in POSIX.1-2008]
           lseek()
           lstat()
           mkdir() [Added in POSIX.1-2008]
           mkdirat() [Added in POSIX.1-2008]
           mkdtemp() [Added in POSIX.1-2008]
           mkfifo() [Added in POSIX.1-2008]
           mkfifoat() [Added in POSIX.1-2008]
           mknod() [Added in POSIX.1-2008]
           mknodat() [Added in POSIX.1-2008]
           mkstemp()
           mktime()
           nftw()
           opendir()
           openlog()
           pathconf()
           pclose()
           perror()
           popen()
           posix_fadvise()
           posix_fallocate()
           posix_madvise()
           posix_openpt()
           posix_spawn()
           posix_spawnp()
           posix_trace_clear()
           posix_trace_close()
           posix_trace_create()
           posix_trace_create_withlog()
           posix_trace_eventtypelist_getnext_id()
           posix_trace_eventtypelist_rewind()
           posix_trace_flush()
           posix_trace_get_attr()
           posix_trace_get_filter()
           posix_trace_get_status()
           posix_trace_getnext_event()
           posix_trace_open()
           posix_trace_rewind()
           posix_trace_set_filter()
           posix_trace_shutdown()
           posix_trace_timedgetnext_event()
           posix_typed_mem_open()
           printf()
           psiginfo() [Added in POSIX.1-2008]
           psignal() [Added in POSIX.1-2008]
           pthread_rwlock_rdlock()
           pthread_rwlock_timedrdlock()
           pthread_rwlock_timedwrlock()
           pthread_rwlock_wrlock()
           putc()
           putc_unlocked()
           putchar()
           putchar_unlocked()
           puts()
           pututxline()
           putwc()
           putwchar()
           readdir()
           readdir_r()
           readlink() [Added in POSIX.1-2008]
           readlinkat() [Added in POSIX.1-2008]
           remove()
           rename()
           renameat() [Added in POSIX.1-2008]
           rewind()
           rewinddir()
           scandir() [Added in POSIX.1-2008]
           scanf()
           seekdir()
           semop()
           setgrent()
           sethostent()
           setnetent()
           setprotoent()
           setpwent()
           setservent()
           setutxent()
           sigpause() [Added in POSIX.1-2008]
           stat()
           strerror()
           strerror_r()
           strftime()
           symlink()
           symlinkat() [Added in POSIX.1-2008]
           sync()
           syslog()
           tmpfile()
           tmpnam()
           ttyname()
           ttyname_r()
           tzset()
           ungetc()
           ungetwc()
           unlink()
           unlinkat() [Added in POSIX.1-2008]
           utime() [Added in POSIX.1-2008]
           utimensat() [Added in POSIX.1-2008]
           utimes() [Added in POSIX.1-2008]
           vdprintf() [Added in POSIX.1-2008]
           vfprintf()
           vfwprintf()
           vprintf()
           vwprintf()
           wcsftime()
           wordexp()
           wprintf()
           wscanf()

       An implementation may also mark other functions not specified in the standard as cancellation points.  In particular,
       an implementation is likely to mark any nonstandard function that may block as a cancellation point.  (This  includes
       most functions that can touch files.)

   Compiling on Linux
       On Linux, programs that use the Pthreads API should be compiled using cc -pthread.

   Linux Implementations of POSIX Threads
       Over time, two threading implementations have been provided by the GNU C library on Linux:

       LinuxThreads
              This is the original Pthreads implementation.  Since glibc 2.4, this implementation is no longer supported.

       NPTL (Native POSIX Threads Library)
              This is the modern Pthreads implementation.  By comparison with LinuxThreads, NPTL provides closer conformance
              to the requirements of the POSIX.1 specification  and  better  performance  when  creating  large  numbers  of
              threads.  NPTL is available since glibc 2.3.2, and requires features that are present in the Linux 2.6 kernel.

       Both  of  these are so-called 1:1 implementations, meaning that each thread maps to a kernel scheduling entity.  Both
       threading implementations employ the  Linux  clone(2)  system  call.   In  NPTL,  thread  synchronization  primitives
       (mutexes, thread joining, etc.) are implemented using the Linux futex(2) system call.

   LinuxThreads
       The notable features of this implementation are the following:

       -  In  addition  to  the main (initial) thread, and the threads that the program creates using pthread_create(3), the
          implementation creates a "manager" thread.  This thread handles thread creation and  termination.   (Problems  can
          result if this thread is inadvertently killed.)

       -  Signals  are used internally by the implementation.  On Linux 2.2 and later, the first three real-time signals are
          used (see also signal(7)).  On older Linux kernels, SIGUSR1 and SIGUSR2 are used.  Applications must avoid the use
          of whichever set of signals is employed by the implementation.

       -  Threads  do not share process IDs.  (In effect, LinuxThreads threads are implemented as processes which share more
          information than usual, but which do not share a common process ID.)  LinuxThreads threads (including the  manager
          thread) are visible as separate processes using ps(1).

       The LinuxThreads implementation deviates from the POSIX.1 specification in a number of ways, including the following:

       -  Calls to getpid(2) return a different value in each thread.

       -  Calls  to  getppid(2)  in  threads other than the main thread return the process ID of the manager thread; instead
          getppid(2) in these threads should return the same value as getppid(2) in the main thread.

       -  When one thread creates a new child process using fork(2), any thread should be able  to  wait(2)  on  the  child.
          However, the implementation only allows the thread that created the child to wait(2) on it.

       -  When  a thread calls execve(2), all other threads are terminated (as required by POSIX.1).  However, the resulting
          process has the same PID as the thread that called execve(2): it should have the same PID as the main thread.

       -  Threads do not share user and group IDs.  This can cause complications with set-user-ID  programs  and  can  cause
          failures in Pthreads functions if an application changes its credentials using seteuid(2) or similar.

       -  Threads do not share a common session ID and process group ID.

       -  Threads do not share record locks created using fcntl(2).

       -  The information returned by times(2) and getrusage(2) is per-thread rather than process-wide.

       -  Threads do not share semaphore undo values (see semop(2)).

       -  Threads do not share interval timers.

       -  Threads do not share a common nice value.

       -  POSIX.1  distinguishes  the  notions  of  signals that are directed to the process as a whole and signals that are
          directed to individual threads.  According to POSIX.1, a process-directed signal (sent using kill(2), for example)
          should  be handled by a single, arbitrarily selected thread within the process.  LinuxThreads does not support the
          notion of process-directed signals: signals may only be sent to specific threads.

       -  Threads have distinct alternate signal stack settings.  However, a new thread's alternate  signal  stack  settings
          are copied from the thread that created it, so that the threads initially share an alternate signal stack.  (A new
          thread should start with no alternate signal stack defined.  If two threads handle signals on their shared  alter‐
          nate signal stack at the same time, unpredictable program failures are likely to occur.)

   NPTL
       With  NPTL,  all of the threads in a process are placed in the same thread group; all members of a thread group share
       the same PID.  NPTL does not employ a manager thread.  NPTL makes internal use of the  first  two  real-time  signals
       (see also signal(7)); these signals cannot be used in applications.

       NPTL still has at least one nonconformance with POSIX.1:

       -  Threads do not share a common nice value.

       Some NPTL nonconformances only occur with older kernels:

       -  The  information  returned  by  times(2)  and getrusage(2) is per-thread rather than process-wide (fixed in kernel
          2.6.9).

       -  Threads do not share resource limits (fixed in kernel 2.6.10).

       -  Threads do not share interval timers (fixed in kernel 2.6.12).

       -  Only the main thread is permitted to start a new session using setsid(2) (fixed in kernel 2.6.16).

       -  Only the main thread is permitted to make the process into a process group leader using setpgid(2) (fixed in  ker‐
          nel 2.6.16).

       -  Threads  have  distinct  alternate signal stack settings.  However, a new thread's alternate signal stack settings
          are copied from the thread that created it, so that the threads initially share an alternate signal  stack  (fixed
          in kernel 2.6.16).

       Note the following further points about the NPTL implementation:

       -  If  the  stack  size  soft  resource limit (see the description of RLIMIT_STACK in setrlimit(2)) is set to a value
          other than unlimited, then this value defines the default stack size for new threads.  To be effective, this limit
          must be set before the program is executed, perhaps using the ulimit -s shell built-in command (limit stacksize in
          the C shell).

   Determining the Threading Implementation
       Since glibc 2.3.2, the getconf(1) command can be used to determine the system's threading implementation,  for  exam‐
       ple:

           bash$ getconf GNU_LIBPTHREAD_VERSION
           NPTL 2.3.4

       With  older  glibc  versions, a command such as the following should be sufficient to determine the default threading
       implementation:

           bash$ $( ldd /bin/ls | grep libc.so | awk '{print $3}' ) | \
                           egrep -i 'threads|nptl'
                   Native POSIX Threads Library by Ulrich Drepper et al

   Selecting the Threading Implementation: LD_ASSUME_KERNEL
       On systems with a glibc that supports both LinuxThreads and NPTL (i.e., glibc 2.3.x), the  LD_ASSUME_KERNEL  environ‐
       ment variable can be used to override the dynamic linker's default choice of threading implementation.  This variable
       tells the dynamic linker to assume that it is running on top of a particular kernel version.  By specifying a  kernel
       version  that  does not provide the support required by NPTL, we can force the use of LinuxThreads.  (The most likely
       reason for doing this is to run a (broken) application that depends on some nonconformant behavior in  LinuxThreads.)
       For example:

           bash$ $( LD_ASSUME_KERNEL=2.2.5 ldd /bin/ls | grep libc.so | \
                           awk '{print $3}' ) | egrep -i 'threads|ntpl'
                   linuxthreads-0.10 by Xavier Leroy

SEE ALSO
       clone(2), futex(2), gettid(2), proc(5), futex(7), sigevent(7), signal(7),
       and   various  Pthreads  manual  pages,  for  example:  pthread_attr_init(3),  pthread_atfork(3),  pthread_cancel(3),
       pthread_cleanup_push(3),   pthread_cond_signal(3),   pthread_cond_wait(3),   pthread_create(3),    pthread_detach(3),
       pthread_equal(3),      pthread_exit(3),      pthread_key_create(3),      pthread_kill(3),      pthread_mutex_lock(3),
       pthread_mutex_unlock(3),  pthread_once(3),   pthread_setcancelstate(3),   pthread_setcanceltype(3),   pthread_setspe‐
       cific(3), pthread_sigmask(3), and pthread_testcancel(3)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-18                                              PTHREADS(7)
************************************************************************************************************
PTHREAD_SELF(3)                                   Linux Programmer's Manual                                  PTHREAD_SELF(3)



NAME
       pthread_self - obtain ID of the calling thread

SYNOPSIS
       #include <pthread.h>

       pthread_t pthread_self(void);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_self() function returns the ID of the calling thread.  This is the same value that is returned in *thread
       in the pthread_create(3) call that created this thread.

RETURN VALUE
       This function always succeeds, returning the calling thread's ID.

ERRORS
       This function always succeeds.

CONFORMING TO
       POSIX.1-2001.

NOTES
       POSIX.1 allows an implementation wide freedom in choosing the type used to represent a thread ID; for example, repre‐
       sentation  using either an arithmetic type or a structure is permitted.  Therefore, variables of type pthread_t can't
       portably be compared using the C equality operator (==); use pthread_equal(3) instead.

       Thread identifiers should be considered opaque: any attempt to use a thread ID other than in pthreads calls  is  non‐
       portable and can lead to unspecified results.

       Thread  IDs  are  only guaranteed to be unique within a process.  A thread ID may be reused after a terminated thread
       has been joined, or a detached thread has terminated.

       The thread ID returned by pthread_self() is not the same thing as the kernel thread ID returned by  a  call  to  get‐
       tid(2).

SEE ALSO
       pthread_create(3), pthread_equal(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-10-24                                          PTHREAD_SELF(3)
************************************************************************************************************
PTHREAD_SETAFFINITY_NP(3)                         Linux Programmer's Manual                        PTHREAD_SETAFFINITY_NP(3)



NAME
       pthread_setaffinity_np, pthread_getaffinity_np - set/get CPU affinity of a thread

SYNOPSIS
       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <pthread.h>

       int pthread_setaffinity_np(pthread_t thread, size_t cpusetsize,
                                  const cpu_set_t *cpuset);
       int pthread_getaffinity_np(pthread_t thread, size_t cpusetsize,
                                  cpu_set_t *cpuset);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_setaffinity_np()  function  sets the CPU affinity mask of the thread thread to the CPU set pointed to by
       cpuset.  If the call is successful, and the thread is not currently running on one of the CPUs in cpuset, then it  is
       migrated to one of those CPUs.

       The  pthread_getaffinity_np() function returns the CPU affinity mask of the thread thread in the buffer pointed to by
       cpuset.

       For more details on CPU affinity masks, see sched_setaffinity(2).  For a description of a set of macros that  can  be
       used to manipulate and inspect CPU sets, see CPU_SET(3).

       The  argument cpusetsize is the length (in bytes) of the buffer pointed to by cpuset.  Typically, this argument would
       be specified as sizeof(cpu_set_t).  (It may be some other value, if using the  macros  described  in  CPU_SET(3)  for
       dynamically allocating a CPU set.)

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       EFAULT A supplied memory address was invalid.

       EINVAL (pthread_setaffinity_np())  The affinity bit mask mask contains no processors that are currently physically on
              the system and permitted to the thread according to any restrictions that may be imposed by the "cpuset" mech‐
              anism described in cpuset(7).

       EINVAL (pthread_setaffinity_np()) cpuset specified a CPU that was outside the set supported by the kernel.  (The ker‐
              nel configuration option CONFIG_NR_CPUS defines the range of the set supported by the kernel data type used to
              represent CPU sets.)

       EINVAL (pthread_getaffinity_np()) cpusetsize is smaller than the size of the affinity mask used by the kernel.

       ESRCH  No thread with the ID thread could be found.

VERSIONS
       These functions are provided by glibc since version 2.3.4.

CONFORMING TO
       These functions are nonstandard GNU extensions; hence the suffix "_np" (nonportable) in the names.

NOTES
       After  a  call to pthread_setaffinity_np(), the set of CPUs on which the thread will actually run is the intersection
       of the set specified in the cpuset argument and the set of CPUs actually present on the system.  The system may  fur‐
       ther  restrict  the  set  of  CPUs on which the thread runs if the "cpuset" mechanism described in cpuset(7) is being
       used.  These restrictions on the actual set of CPUs on which the thread will run are silently imposed by the kernel.

       These functions are implemented on top of the sched_setaffinity(2) and sched_getaffinity(2) system calls.

       In glibc 2.3.3 only, versions of these functions were provided that did not have a cpusetsize argument.  Instead  the
       CPU set size given to the underlying system calls was always sizeof(cpu_set_t).

       A new thread created by pthread_create() inherits a copy of its creator's CPU affinity mask.

EXAMPLE
       In  the following program, the main thread uses pthread_setaffinity_np() to set its CPU affinity mask to include CPUs
       0 to 7 (which may not all be available on the system), and then calls pthread_getaffinity_np() to check the resulting
       CPU affinity mask of the thread.

       #define _GNU_SOURCE
       #include <pthread.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <errno.h>

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       int
       main(int argc, char *argv[])
       {
           int s, j;
           cpu_set_t cpuset;
           pthread_t thread;

           thread = pthread_self();

           /* Set affinity mask to include CPUs 0 to 7 */

           CPU_ZERO(&cpuset);
           for (j = 0; j < 8; j++)
               CPU_SET(j, &cpuset);

           s = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
           if (s != 0)
               handle_error_en(s, "pthread_setaffinity_np");

           /* Check the actual affinity mask assigned to the thread */

           s = pthread_getaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
           if (s != 0)
               handle_error_en(s, "pthread_getaffinity_np");

           printf("Set returned by pthread_getaffinity_np() contained:\n");
           for (j = 0; j < CPU_SETSIZE; j++)
               if (CPU_ISSET(j, &cpuset))
                   printf("    CPU %d\n", j);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       sched_getcpu(3),   sched_setaffinity(2),   sched_setscheduler(2),   pthread_attr_setaffinity_np(3),  pthread_self(3),
       cpuset(7), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-09-10                                PTHREAD_SETAFFINITY_NP(3)
************************************************************************************************************
PTHREAD_SETCANCELSTATE(3)                         Linux Programmer's Manual                        PTHREAD_SETCANCELSTATE(3)



NAME
       pthread_setcancelstate, pthread_setcanceltype - set cancelability state and type

SYNOPSIS
       #include <pthread.h>

       int pthread_setcancelstate(int state, int *oldstate);
       int pthread_setcanceltype(int type, int *oldtype);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_setcancelstate()  sets  the  cancelability state of the calling thread to the value given in state.  The
       previous cancelability state of the thread is returned in the buffer pointed to by oldstate.  The state argument must
       have one of the following values:

       PTHREAD_CANCEL_ENABLE
              The  thread  is cancelable.  This is the default cancelability state in all new threads, including the initial
              thread.  The thread's cancelability type determines when a cancelable thread will respond  to  a  cancellation
              request.

       PTHREAD_CANCEL_DISABLE
              The  thread  is  not  cancelable.  If a cancellation request is received, it is blocked until cancelability is
              enabled.

       The pthread_setcanceltype() sets the cancelability type of the calling thread to the value given in type.  The previ‐
       ous  cancelability  type  of the thread is returned in the buffer pointed to by oldtype.  The type argument must have
       one of the following values:

       PTHREAD_CANCEL_DEFERRED
              A cancellation request is deferred until the thread next calls a function that is a  cancellation  point  (see
              pthreads(7)).  This is the default cancelability type in all new threads, including the initial thread.

       PTHREAD_CANCEL_ASYNCHRONOUS
              The  thread can be canceled at any time.  (Typically, it will be canceled immediately upon receiving a cancel‐
              lation request, but the system doesn't guarantee this.)

       The set-and-get operation performed by each of these functions is atomic with respect to other threads in the process
       calling the same function.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       The pthread_setcancelstate() can fail with the following error:

       EINVAL Invalid value for state.

       The pthread_setcanceltype() can fail with the following error:

       EINVAL Invalid value for type.

CONFORMING TO
       POSIX.1-2001.

NOTES
       For details of what happens when a thread is canceled, see pthread_cancel(3).

       Briefly disabling cancelability is useful if a thread performs some critical action that must not be interrupted by a
       cancellation request.  Beware of disabling cancelability for long periods, or around operations that  may  block  for
       long periods, since that will render the thread unresponsive to cancellation requests.

       Setting  the  cancelability type to PTHREAD_CANCEL_ASYNCHRONOUS is rarely useful.  Since the thread could be canceled
       at any time, it cannot safely reserve resources (e.g., allocating memory  with  malloc(3)),  acquire  mutexes,  sema‐
       phores,  or  locks,  and so on.  Reserving resources is unsafe because the application has no way of knowing what the
       state of these resources is when the thread is canceled; that is, did cancellation occur before  the  resources  were
       reserved,  while  they were reserved, or after they were released?  Furthermore, some internal data structures (e.g.,
       the linked list of free blocks managed by the malloc(3) family of functions) may be left in an inconsistent state  if
       cancellation  occurs  in the middle of the function call.  Consequently, clean-up handlers cease to be useful.  Func‐
       tions that can be safely asynchronously canceled are called async-cancel-safe functions.  POSIX.1-2001 only  requires
       that  pthread_cancel(3),  pthread_setcancelstate(),  and  pthread_setcanceltype()  be async-cancel-safe.  In general,
       other library functions can't be safely called from an asynchronously cancelable thread.   One  of  the  few  circum‐
       stances in which asynchronous cancelability is useful is for cancellation of a thread that is in a pure compute-bound
       loop.

       The Linux threading implementations permit the oldstate argument of pthread_setcancelstate() to  be  NULL,  in  which
       case  the  information  about the previous cancelability state is not returned to the caller.  Many other implementa‐
       tions also permit a NULL oldstat argument, but POSIX.1-2001 does not specify this  point,  so  portable  applications
       should  always specify a non-NULL value in oldstate.  A precisely analogous set of statements applies for the oldtype
       argument of pthread_setcanceltype().

EXAMPLE
       See pthread_cancel(3).

SEE ALSO
       pthread_cleanup_push(3), pthread_cancel(3), pthread_testcancel(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-24                                PTHREAD_SETCANCELSTATE(3)
************************************************************************************************************
PTHREAD_SETCANCELSTATE(3)                         Linux Programmer's Manual                        PTHREAD_SETCANCELSTATE(3)



NAME
       pthread_setcancelstate, pthread_setcanceltype - set cancelability state and type

SYNOPSIS
       #include <pthread.h>

       int pthread_setcancelstate(int state, int *oldstate);
       int pthread_setcanceltype(int type, int *oldtype);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_setcancelstate()  sets  the  cancelability state of the calling thread to the value given in state.  The
       previous cancelability state of the thread is returned in the buffer pointed to by oldstate.  The state argument must
       have one of the following values:

       PTHREAD_CANCEL_ENABLE
              The  thread  is cancelable.  This is the default cancelability state in all new threads, including the initial
              thread.  The thread's cancelability type determines when a cancelable thread will respond  to  a  cancellation
              request.

       PTHREAD_CANCEL_DISABLE
              The  thread  is  not  cancelable.  If a cancellation request is received, it is blocked until cancelability is
              enabled.

       The pthread_setcanceltype() sets the cancelability type of the calling thread to the value given in type.  The previ‐
       ous  cancelability  type  of the thread is returned in the buffer pointed to by oldtype.  The type argument must have
       one of the following values:

       PTHREAD_CANCEL_DEFERRED
              A cancellation request is deferred until the thread next calls a function that is a  cancellation  point  (see
              pthreads(7)).  This is the default cancelability type in all new threads, including the initial thread.

       PTHREAD_CANCEL_ASYNCHRONOUS
              The  thread can be canceled at any time.  (Typically, it will be canceled immediately upon receiving a cancel‐
              lation request, but the system doesn't guarantee this.)

       The set-and-get operation performed by each of these functions is atomic with respect to other threads in the process
       calling the same function.

RETURN VALUE
       On success, these functions return 0; on error, they return a nonzero error number.

ERRORS
       The pthread_setcancelstate() can fail with the following error:

       EINVAL Invalid value for state.

       The pthread_setcanceltype() can fail with the following error:

       EINVAL Invalid value for type.

CONFORMING TO
       POSIX.1-2001.

NOTES
       For details of what happens when a thread is canceled, see pthread_cancel(3).

       Briefly disabling cancelability is useful if a thread performs some critical action that must not be interrupted by a
       cancellation request.  Beware of disabling cancelability for long periods, or around operations that  may  block  for
       long periods, since that will render the thread unresponsive to cancellation requests.

       Setting  the  cancelability type to PTHREAD_CANCEL_ASYNCHRONOUS is rarely useful.  Since the thread could be canceled
       at any time, it cannot safely reserve resources (e.g., allocating memory  with  malloc(3)),  acquire  mutexes,  sema‐
       phores,  or  locks,  and so on.  Reserving resources is unsafe because the application has no way of knowing what the
       state of these resources is when the thread is canceled; that is, did cancellation occur before  the  resources  were
       reserved,  while  they were reserved, or after they were released?  Furthermore, some internal data structures (e.g.,
       the linked list of free blocks managed by the malloc(3) family of functions) may be left in an inconsistent state  if
       cancellation  occurs  in the middle of the function call.  Consequently, clean-up handlers cease to be useful.  Func‐
       tions that can be safely asynchronously canceled are called async-cancel-safe functions.  POSIX.1-2001 only  requires
       that  pthread_cancel(3),  pthread_setcancelstate(),  and  pthread_setcanceltype()  be async-cancel-safe.  In general,
       other library functions can't be safely called from an asynchronously cancelable thread.   One  of  the  few  circum‐
       stances in which asynchronous cancelability is useful is for cancellation of a thread that is in a pure compute-bound
       loop.

       The Linux threading implementations permit the oldstate argument of pthread_setcancelstate() to  be  NULL,  in  which
       case  the  information  about the previous cancelability state is not returned to the caller.  Many other implementa‐
       tions also permit a NULL oldstat argument, but POSIX.1-2001 does not specify this  point,  so  portable  applications
       should  always specify a non-NULL value in oldstate.  A precisely analogous set of statements applies for the oldtype
       argument of pthread_setcanceltype().

EXAMPLE
       See pthread_cancel(3).

SEE ALSO
       pthread_cleanup_push(3), pthread_cancel(3), pthread_testcancel(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-24                                PTHREAD_SETCANCELSTATE(3)
************************************************************************************************************
PTHREAD_SETCONCURRENCY(3)                         Linux Programmer's Manual                        PTHREAD_SETCONCURRENCY(3)



NAME
       pthread_setconcurrency, pthread_getconcurrency - set/get the concurrency level

SYNOPSIS
       #include <pthread.h>

       int pthread_setconcurrency(int new_level);
       int pthread_getconcurrency(void);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_setconcurrency()  function  informs  the  implementation of the application's desired concurrency level,
       specified in new_level.  The implementation only takes this as a hint: POSIX.1 does not specify the level of  concur‐
       rency that should be provided as a result of calling pthread_setconcurrency().

       Specifying new_level as 0 instructs the implementation to manage the concurrency level as it deems appropriate.

       pthread_getconcurrency() returns the current value of the concurrency level for this process.

RETURN VALUE
       On success, pthread_setconcurrency() returns 0; on error, it returns a nonzero error number.

       pthread_getconcurrency()  always  succeeds, returning the concurrency level set by a previous call to pthread_setcon‐
       currency(), or 0, if pthread_setconcurrency() has not previously been called.

ERRORS
       pthread_setconcurrency() can fail with the following error:

       EINVAL new_level is negative.

       POSIX.1-2001 also documents an EAGAIN error ("the value specified by new_level would cause a system  resource  to  be
       exceeded").

VERSIONS
       These functions are available in glibc since version 2.1.

CONFORMING TO
       POSIX.1-2001.

NOTES
       The default concurrency level is 0.

       Concurrency levels are only meaningful for M:N threading implementations, where at any moment a subset of a process's
       set of user-level threads may be bound to a smaller number of kernel-scheduling entities.   Setting  the  concurrency
       level  allows the application to give the system a hint as to the number of kernel-scheduling entities that should be
       provided for efficient execution of the application.

       Both LinuxThreads and NPTL are 1:1 threading implementations, so setting the concurrency level has  no  meaning.   In
       other  words,  on Linux these functions merely exist for compatibility with other systems, and they have no effect on
       the execution of a program.

SEE ALSO
       pthread_attr_setscope(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2009-04-10                                PTHREAD_SETCONCURRENCY(3)
************************************************************************************************************
PTHREAD_SETSCHEDPARAM(3)                          Linux Programmer's Manual                         PTHREAD_SETSCHEDPARAM(3)



NAME
       pthread_setschedparam, pthread_getschedparam - set/get scheduling policy and parameters of a thread

SYNOPSIS
       #include <pthread.h>

       pthread_setschedparam(pthread_t thread, int policy,
                             const struct sched_param *param);
       pthread_getschedparam(pthread_t thread, int *policy,
                             struct sched_param *param);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_setschedparam() function sets the scheduling policy and parameters of the thread thread.

       policy  specifies  the  new  scheduling policy for thread.  The supported values for policy, and their semantics, are
       described in sched_setscheduler(2).

       The structure pointed to by param specifies the new scheduling parameters  for  thread.   Scheduling  parameters  are
       maintained in the following structure:

           struct sched_param {
               int sched_priority;     /* Scheduling priority */
           };

       As  can be seen, only one scheduling parameter is supported.  For details of the permitted ranges for scheduling pri‐
       orities in each scheduling policy, see sched_setscheduler(2).

       The pthread_getschedparam() function returns the scheduling policy and parameters of the thread thread, in  the  buf‐
       fers  pointed  to  by  policy  and  param,  respectively.  The returned priority value is that set by the most recent
       pthread_setschedparam(), pthread_setschedprio(3), or pthread_create(3) call that affected thread.  The returned  pri‐
       ority  does not reflect any temporary priority adjustments as a result of calls to any priority inheritance or prior‐
       ity ceiling functions (see, for example, pthread_mutexattr_setprioceiling(3) and pthread_mutexattr_setprotocol(3)).

RETURN VALUE
       On success, these functions return 0; on error, they return  a  nonzero  error  number.   If  pthread_setschedparam()
       fails, the scheduling policy and parameters of thread are not changed.

ERRORS
       Both of these functions can fail with the following error:

       ESRCH  No thread with the ID thread could be found.

       pthread_setschedparam() may additionally fail with the following errors:

       EINVAL policy is not a recognized policy, or param does not make sense for the policy.

       EPERM  The caller does not have appropriate privileges to set the specified scheduling policy and parameters.

       POSIX.1-2001  also  documents  an  ENOTSUP ("attempt was made to set the policy or scheduling parameters to an unsup‐
       ported value") error for pthread_setschedparam().

CONFORMING TO
       POSIX.1-2001.

NOTES
       For a description of the permissions required to, and the effect of, changing a thread's scheduling policy and prior‐
       ity, and details of the permitted ranges for priorities in each scheduling policy, see sched_setscheduler(2).

EXAMPLE
       The  program below demonstrates the use of pthread_setschedparam() and pthread_getschedparam(), as well as the use of
       a number of other scheduling-related pthreads functions.

       In the following run, the main thread sets its scheduling policy to SCHED_FIFO with a priority of 10, and initializes
       a  thread attributes object with a scheduling policy attribute of SCHED_RR and a scheduling priority attribute of 20.
       The program then  sets  (using  pthread_attr_setinheritsched(3))  the  inherit  scheduler  attribute  of  the  thread
       attributes  object  to  PTHREAD_EXPLICIT_SCHED, meaning that threads created using this attributes object should take
       their scheduling attributes from the thread attributes object.  The program then creates a thread  using  the  thread
       attributes object, and that thread displays its scheduling policy and priority.

           $ su      # Need privilege to set real-time scheduling policies
           Password:
           # ./a.out -mf10 -ar20 -i e
           Scheduler settings of main thread
               policy=SCHED_FIFO, priority=10

           Scheduler settings in 'attr'
               policy=SCHED_RR, priority=20
               inheritsched is EXPLICIT

           Scheduler attributes of new thread
               policy=SCHED_RR, priority=20

       In  the above output, one can see that the scheduling policy and priority were taken from the values specified in the
       thread attributes object.

       The  next  run  is  the  same  as  the  previous,  except  that  the  inherit   scheduler   attribute   is   set   to
       PTHREAD_INHERIT_SCHED,  meaning  that threads created using the thread attributes object should ignore the scheduling
       attributes specified in the attributes object and instead take their scheduling attributes from the creating thread.

           # ./a.out -mf10 -ar20 -i i
           Scheduler settings of main thread
               policy=SCHED_FIFO, priority=10

           Scheduler settings in 'attr'
               policy=SCHED_RR, priority=20
               inheritsched is INHERIT

           Scheduler attributes of new thread
               policy=SCHED_FIFO, priority=10

       In the above output, one can see that the scheduling policy and priority were taken from the creating thread,  rather
       than the thread attributes object.

       Note  that if we had omitted the -i i option, the output would have been the same, since PTHREAD_INHERIT_SCHED is the
       default for the inherit scheduler attribute.

   Program source

       /* pthreads_sched_test.c */

       #include <pthread.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <errno.h>

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       static void
       usage(char *prog_name, char *msg)
       {
           if (msg != NULL)
               fputs(msg, stderr);

           fprintf(stderr, "Usage: %s [options]\n", prog_name);
           fprintf(stderr, "Options are:\n");
       #define fpe(msg) fprintf(stderr, "\t%s", msg);          /* Shorter */
           fpe("-a<policy><prio> Set scheduling policy and priority in\n");
           fpe("                 thread attributes object\n");
           fpe("                 <policy> can be\n");
           fpe("                     f  SCHED_FIFO\n");
           fpe("                     r  SCHED_RR\n");
           fpe("                     o  SCHED_OTHER\n");
           fpe("-A               Use default thread attributes object\n");
           fpe("-i {e|s}         Set inherit scheduler attribute to\n");
           fpe("                 'explicit' or 'inherit'\n");
           fpe("-m<policy><prio> Set scheduling policy and priority on\n");
           fpe("                 main thread before pthread_create() call\n");
           exit(EXIT_FAILURE);
       } /* usage */

       static int
       get_policy(char p, int *policy)
       {
           switch (p) {
           case 'f': *policy = SCHED_FIFO;     return 1;
           case 'r': *policy = SCHED_RR;       return 1;
           case 'o': *policy = SCHED_OTHER;    return 1;
           default:  return 0;
           }
       } /* get_policy */

       static void
       display_sched_attr(int policy, struct sched_param *param)
       {
           printf("    policy=%s, priority=%d\n",
                   (policy == SCHED_FIFO)  ? "SCHED_FIFO" :
                   (policy == SCHED_RR)    ? "SCHED_RR" :
                   (policy == SCHED_OTHER) ? "SCHED_OTHER" :
                   "???",
                   param->sched_priority);
       } /* display_sched_attr */

       static void
       display_thread_sched_attr(char *msg)
       {
           int policy, s;
           struct sched_param param;

           s = pthread_getschedparam(pthread_self(), &policy, &param);
           if (s != 0)
               handle_error_en(s, "pthread_getschedparam");

           printf("%s\n", msg);
           display_sched_attr(policy, &param);
       } /* display_thread_sched_attr */

       static void *
       thread_start(void *arg)
       {
           display_thread_sched_attr("Scheduler attributes of new thread");

           return NULL;
       } /* thread_start */

       int
       main(int argc, char *argv[])
       {
           int s, opt, inheritsched, use_null_attrib, policy;
           pthread_t thread;
           pthread_attr_t attr;
           pthread_attr_t *attrp;
           char *attr_sched_str, *main_sched_str, *inheritsched_str;
           struct sched_param param;

           /* Process command-line options */

           use_null_attrib = 0;
           attr_sched_str = NULL;
           main_sched_str = NULL;
           inheritsched_str = NULL;

           while ((opt = getopt(argc, argv, "a:Ai:m:")) != -1) {
               switch (opt) {
               case 'a': attr_sched_str = optarg;      break;
               case 'A': use_null_attrib = 1;          break;
               case 'i': inheritsched_str = optarg;    break;
               case 'm': main_sched_str = optarg;      break;
               default:  usage(argv[0], "Unrecognized option\n");
               }
           }

           if (use_null_attrib &&
                   (inheritsched_str != NULL || attr_sched_str != NULL))
               usage(argv[0], "Can't specify -A with -i or -a\n");

           /* Optionally set scheduling attributes of main thread,
              and display the attributes */

           if (main_sched_str != NULL) {
               if (!get_policy(main_sched_str[0], &policy))
                   usage(argv[0], "Bad policy for main thread (-s)\n");
               param.sched_priority = strtol(&main_sched_str[1], NULL, 0);

               s = pthread_setschedparam(pthread_self(), policy, &param);
               if (s != 0)
                   handle_error_en(s, "pthread_setschedparam");
           }

           display_thread_sched_attr("Scheduler settings of main thread");
           printf("\n");

           /* Initialize thread attributes object according to options */

           attrp = NULL;

           if (!use_null_attrib) {
               s = pthread_attr_init(&attr);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_init");
               attrp = &attr;
           }

           if (inheritsched_str != NULL) {
               if (inheritsched_str[0] == 'e')
                   inheritsched = PTHREAD_EXPLICIT_SCHED;
               else if (inheritsched_str[0] == 'i')
                   inheritsched = PTHREAD_INHERIT_SCHED;
               else
                   usage(argv[0], "Value for -i must be 'e' or 'i'\n");

               s = pthread_attr_setinheritsched(&attr, inheritsched);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setinheritsched");
           }

           if (attr_sched_str != NULL) {
               if (!get_policy(attr_sched_str[0], &policy))
                   usage(argv[0],
                           "Bad policy for 'attr' (-a)\n");
               param.sched_priority = strtol(&attr_sched_str[1], NULL, 0);

               s = pthread_attr_setschedpolicy(&attr, policy);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setschedpolicy");
               s = pthread_attr_setschedparam(&attr, &param);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setschedparam");
           }

           /* If we initialized a thread attributes object, display
              the scheduling attributes that were set in the object */

           if (attrp != NULL) {
               s = pthread_attr_getschedparam(&attr, &param);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_getschedparam");
               s = pthread_attr_getschedpolicy(&attr, &policy);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_getschedpolicy");

               printf("Scheduler settings in 'attr'\n");
               display_sched_attr(policy, &param);

               s = pthread_attr_getinheritsched(&attr, &inheritsched);
               printf("    inheritsched is %s\n",
                       (inheritsched == PTHREAD_INHERIT_SCHED)  ? "INHERIT" :
                       (inheritsched == PTHREAD_EXPLICIT_SCHED) ? "EXPLICIT" :
                       "???");
               printf("\n");
           }

           /* Create a thread that will display its scheduling attributes */

           s = pthread_create(&thread, attrp, &thread_start, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           /* Destroy unneeded thread attributes object */

           s = pthread_attr_destroy(&attr);
           if (s != 0)
               handle_error_en(s, "pthread_attr_destroy");

           s = pthread_join(thread, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_join");

           exit(EXIT_SUCCESS);
       } /* main */

SEE ALSO
       getrlimit(2),   sched_get_priority_min(2),   sched_setscheduler(2),   pthread_attr_init(3),    pthread_attr_setinher‐
       itsched(3),   pthread_attr_setschedparam(3),  pthread_attr_setschedpolicy(3),  pthread_setschedprio(3),  pthread_cre‐
       ate(3), pthread_self(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-17                                 PTHREAD_SETSCHEDPARAM(3)
************************************************************************************************************
PTHREAD_SETSCHEDPRIO(3)                           Linux Programmer's Manual                          PTHREAD_SETSCHEDPRIO(3)



NAME
       pthread_setschedprio - set scheduling priority of a thread

SYNOPSIS
       #include <pthread.h>

       pthread_setschedprio(pthread_t thread, int prio);

       Compile and link with -pthread.

DESCRIPTION
       The pthread_setschedprio() function sets the scheduling priority of the thread thread to the value specified in prio.
       (By contrast pthread_setschedparam(3) changes both the scheduling policy and priority of a thread.)

RETURN VALUE
       On success, this function returns 0; on error, it returns a nonzero error number.  If  pthread_setschedprio()  fails,
       the scheduling priority of thread is not changed.

ERRORS
       EINVAL prio is not valid for the scheduling policy of the specified thread.

       EPERM  The caller does not have appropriate privileges to set the specified priority.

       ESRCH  No thread with the ID thread could be found.

       POSIX.1-2001  also  documents  an  ENOTSUP ("attempt was made to set the priority to an unsupported value") error for
       pthread_setschedparam().

VERSIONS
       This function is available in glibc since version 2.3.4.

CONFORMING TO
       POSIX.1-2001.

NOTES
       For a description of the permissions required to, and the effect of, changing a  thread's  scheduling  priority,  and
       details of the permitted ranges for priorities in each scheduling policy, see sched_setscheduler(2).

SEE ALSO
       getrlimit(2),    sched_get_priority_min(2),   sched_setscheduler(2),   pthread_attr_init(3),   pthread_attr_setinher‐
       itsched(3),  pthread_attr_setschedparam(3),  pthread_attr_setschedpolicy(3),  pthread_setschedparam(3),  pthread_cre‐
       ate(3), pthread_self(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-06                                  PTHREAD_SETSCHEDPRIO(3)
************************************************************************************************************
PTHREAD_SIGMASK(3)                                Linux Programmer's Manual                               PTHREAD_SIGMASK(3)



NAME
       pthread_sigmask - examine and change mask of blocked signals

SYNOPSIS
       #include <signal.h>

       int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);

       Compile and link with -pthread.

DESCRIPTION
       The  pthread_sigmask()  function  is just like sigprocmask(2), with the difference that its use in multithreaded pro‐
       grams is explicitly specified by POSIX.1-2001.  Other differences are noted in this page.

       For a description of the arguments and operation of this function, see sigprocmask(2).

RETURN VALUE
       On success, pthread_sigmask() returns 0; on error, it returns an error number.

ERRORS
       See sigprocmask(2).

CONFORMING TO
       POSIX.1-2001.

NOTES
       A new thread inherits a copy of its creator's signal mask.

EXAMPLE
       The program below blocks some signals in the main thread, and then creates a dedicated thread to fetch those  signals
       via sigwait(3).  The following shell session demonstrates its use:

           $ ./a.out &
           [1] 5423
           $ kill -QUIT %1
           Signal handling thread got signal 3
           $ kill -USR1 %1
           Signal handling thread got signal 10
           $ kill -TERM %1
           [1]+  Terminated              ./a.out

   Program source

       #include <pthread.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <signal.h>
       #include <errno.h>

       /* Simple error handling functions */

       #define handle_error_en(en, msg) \
               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

       static void *
       sig_thread(void *arg)
       {
           sigset_t *set = (sigset_t *) arg;
           int s, sig;

           for (;;) {
               s = sigwait(set, &sig);
               if (s != 0)
                   handle_error_en(s, "sigwait");
               printf("Signal handling thread got signal %d\n", sig);
           }
       }

       int
       main(int argc, char *argv[])
       {
           pthread_t thread;
           sigset_t set;
           int s;

           /* Block SIGINT; other threads created by main() will inherit
              a copy of the signal mask. */

           sigemptyset(&set);
           sigaddset(&set, SIGQUIT);
           sigaddset(&set, SIGUSR1);
           s = pthread_sigmask(SIG_BLOCK, &set, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_sigmask");

           s = pthread_create(&thread, NULL, &sig_thread, (void *) &set);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           /* Main thread carries on to create other threads and/or do
              other work */

           pause();            /* Dummy pause so we can test program */
       }

SEE ALSO
       sigaction(2), sigpending(2), sigprocmask(2) pthread_create(3), pthread_kill(3), sigsetops(3), pthreads(7), signal(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2009-01-25                                       PTHREAD_SIGMASK(3)
************************************************************************************************************
PTHREAD_TESTCANCEL(3)                             Linux Programmer's Manual                            PTHREAD_TESTCANCEL(3)



NAME
       pthread_testcancel - request delivery of any pending cancellation request

SYNOPSIS
       #include <pthread.h>

       void pthread_testcancel(void);

       Compile and link with -pthread.

DESCRIPTION
       Calling  pthread_testcancel() creates a cancellation point within the calling thread, so that a thread that is other‐
       wise executing code that contains no cancellation points will respond to a cancellation request.

       If cancelability is disabled (using pthread_setcancelstate(3)), or no cancellation request is pending, then a call to
       pthread_cancel() has no effect.

RETURN VALUE
       This  function  does  not return a value.  If the calling thread is canceled as a consequence of a call to this func‐
       tion, then the function does not return.

ERRORS
       This function always succeeds.

CONFORMING TO
       POSIX.1-2001.

EXAMPLE
       See pthread_cleanup_push(3).

SEE ALSO
       pthread_cancel(3), pthread_cleanup_push(3), pthread_setcancelstate(3), pthreads(7)

COLOPHON
       This page is part of release 3.27 of the Linux man-pages project.  A description  of  the  project,  and  information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2008-11-17                                    PTHREAD_TESTCANCEL(3)
************************************************************************************************************
PTHREAD_TRYJOIN_NP(3)                             Linux Programmer's Manual                            PTHREAD_TRYJOIN_NP(3)



NAME
       pthread_tryjoin_np, pthread_timedjoin_np - try to join with a terminated thread

SYNOPSIS
       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <pthread.h>

       int pthread_tryjoin_np(pthread_t thread, void **retval);

       int pthread_timedjoin_np(pthread_t thread, void **retval,
                                const struct timespec *abstime);

       Compile and link with -pthread.

DESCRIPTION
       These functions operate in the same way as pthread_join(3), except for the differences described on this page.

       The  pthread_tryjoin_np()  function  performs a nonblocking join with the thread thread, returning the exit status of
       the thread in *retval.  If thread has not yet terminated, then instead of blocking, as is  done  by  pthread_join(3),
       the call returns an error.

       The  pthread_timedjoin_np()  function  performs a join-with-timeout.  If thread has not yet terminated, then the call
       blocks until a maximum time, specified in abstime.  If the timeout expires before thread terminates, the call returns
       an  error.  The abstime argument is a structure of the following form, specifying an absolute time measured since the
       Epoch (see time(2)):

           struct timespec {
               time_t tv_sec;     /* seconds */
               long   tv_nsec;    /* nanoseconds */
           };

RETURN VALUE
       On success, these functions return 0; on error, they return an error number.

ERRORS
       These functions can fail with the same errors as pthread_join(3).  pthread_tryjoin_np() can in addition fail with the
       following error:

       EBUSY  thread had not yet terminated at the time of the call.

       pthread_timedjoin_np() can in addition fail with the following error:

       ETIMEDOUT
              The call timed out before thread terminated.

       pthread_timedjoin_np() never returns the error EINTR.

VERSIONS
       These functions first appeared in glibc in version 2.3.3.

CONFORMING TO
       These functions are nonstandard GNU extensions; hence the suffix "_np" (nonportable) in the names.

EXAMPLE
       The following code waits to join for up to 5 seconds:

           struct timespec ts;
           int s;

           ...

           if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {
            /* Handle error */
           }

           ts.tv_sec += 5;

           s = pthread_timedjoin_np(thread, NULL, &ts);
           if (s != 0) {
               /* Handle error */
           }

SEE ALSO
       clock_gettime(2), pthread_join(3), pthread_exit(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-09-10                                    PTHREAD_TRYJOIN_NP(3)
************************************************************************************************************
PTHREAD_TRYJOIN_NP(3)                             Linux Programmer's Manual                            PTHREAD_TRYJOIN_NP(3)



NAME
       pthread_tryjoin_np, pthread_timedjoin_np - try to join with a terminated thread

SYNOPSIS
       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <pthread.h>

       int pthread_tryjoin_np(pthread_t thread, void **retval);

       int pthread_timedjoin_np(pthread_t thread, void **retval,
                                const struct timespec *abstime);

       Compile and link with -pthread.

DESCRIPTION
       These functions operate in the same way as pthread_join(3), except for the differences described on this page.

       The  pthread_tryjoin_np()  function  performs a nonblocking join with the thread thread, returning the exit status of
       the thread in *retval.  If thread has not yet terminated, then instead of blocking, as is  done  by  pthread_join(3),
       the call returns an error.

       The  pthread_timedjoin_np()  function  performs a join-with-timeout.  If thread has not yet terminated, then the call
       blocks until a maximum time, specified in abstime.  If the timeout expires before thread terminates, the call returns
       an  error.  The abstime argument is a structure of the following form, specifying an absolute time measured since the
       Epoch (see time(2)):

           struct timespec {
               time_t tv_sec;     /* seconds */
               long   tv_nsec;    /* nanoseconds */
           };

RETURN VALUE
       On success, these functions return 0; on error, they return an error number.

ERRORS
       These functions can fail with the same errors as pthread_join(3).  pthread_tryjoin_np() can in addition fail with the
       following error:

       EBUSY  thread had not yet terminated at the time of the call.

       pthread_timedjoin_np() can in addition fail with the following error:

       ETIMEDOUT
              The call timed out before thread terminated.

       pthread_timedjoin_np() never returns the error EINTR.

VERSIONS
       These functions first appeared in glibc in version 2.3.3.

CONFORMING TO
       These functions are nonstandard GNU extensions; hence the suffix "_np" (nonportable) in the names.

EXAMPLE
       The following code waits to join for up to 5 seconds:

           struct timespec ts;
           int s;

           ...

           if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {
            /* Handle error */
           }

           ts.tv_sec += 5;

           s = pthread_timedjoin_np(thread, NULL, &ts);
           if (s != 0) {
               /* Handle error */
           }

SEE ALSO
       clock_gettime(2), pthread_join(3), pthread_exit(3), pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2010-09-10                                    PTHREAD_TRYJOIN_NP(3)
************************************************************************************************************
PTHREAD_YIELD(3)                                  Linux Programmer's Manual                                 PTHREAD_YIELD(3)



NAME
       pthread_yield - yield the processor

SYNOPSIS
       #include <pthread.h>

       int pthread_yield(void);

       Compile and link with -pthread.

DESCRIPTION
       pthread_yield()  causes  the  calling thread to relinquish the CPU.  The thread is placed at the end of the run queue
       for its static priority and another thread is scheduled to run.  For further details, see sched_yield(2)

RETURN VALUE
       On success, pthread_yield() returns 0; on error, it returns an error number.

ERRORS
       On Linux, this call always succeeds (but portable and future-proof applications should nevertheless handle a possible
       error return).

CONFORMING TO
       This call is nonstandard, but present on several other systems.  Use the standardized sched_yield(2) instead.

NOTES
       On Linux, this function is implemented as a call to sched_yield(2).

SEE ALSO
       sched_setscheduler(2), sched_yield(2) pthreads(7)

COLOPHON
       This  page  is  part  of  release 3.27 of the Linux man-pages project.  A description of the project, and information
       about reporting bugs, can be found at http://www.kernel.org/doc/man-pages/.



Linux                                                    2009-04-10                                         PTHREAD_YIELD(3)
************************************************************************************************************
